<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">Ext.define(&#39;BasiGX.plugin.HoverClick&#39;, {
    extend: &#39;BasiGX.plugin.Hover&#39;,

    alias: &#39;plugin.hoverClick&#39;,
    pluginId: &#39;hoverClick&#39;,

    inheritableStatics: {
<span id='global-property-LAYER_CLICKABLE_PROPERTY_NAME'>        /**
</span>         * The property of a layer that holds a boolean value which indicates
         * whether this layer qualifies for clicking.
         */
        LAYER_CLICKABLE_PROPERTY_NAME: &#39;clickable&#39;
    },

    config: {
<span id='global-property-hoverable'>        /**
</span>         * Enable/Disable hovering globally. If false, the plugin will not
         * listen to any hover event, regardless if a layer has a truthy
         * hoverable property.
         */
        hoverable: true,
<span id='global-property-clickable'>        /**
</span>         * Enable/Disable clicking globally. If false, the plugin will not
         * listen to any click event, regardless if a layer has a truthy
         * clickable property.
         */
        clickable: true,

<span id='global-property-clickActive'>        /**
</span>         * Control state of click event on the map. If the underlying HSI button
         * gets untoggled, click interaction on the map should be deactivated.
         */
        clickActive: true
    },

    init: function (cmp) {
        var me = this;

        me.checkSelectEventOrigin();

        me.addHoverVectorLayerSource();
        me.addHoverVectorLayer();

        if (me.getEnableHoverSelection() &amp;&amp; me.getClickable()) {
            me.addHoverVectorLayerInteraction();
        }

        me.setupMapEventListeners();
        me.setCmp(cmp);

        cmp.setPointerRest(me.getPointerRest());
        cmp.setPointerRestInterval(me.getPointerRestInterval());
        cmp.setPointerRestPixelTolerance(me.getPointerRestPixelTolerance());

        if (me.getHoverable()) {
            cmp.on(&#39;pointerrest&#39;, me.onPointerRest, me);
            cmp.on(&#39;pointerrestout&#39;, me.cleanupHoverArtifacts, me);
        }
    },

<span id='global-method-setupMapEventListeners'>    /**
</span>     * Adds the onClick event to the registered super events,
     * if clickable is true.
     *
     * @private
     */
    setupMapEventListeners: function () {
        var me = this;
        me.callParent();

        if (me.getClickable() &amp;&amp; me.getClickActive()) {
            var mapComponent = me.getCmp();
            var map = mapComponent.getMap();
            map.on(&#39;click&#39;, me.onClick.bind(me));
        }
    },

<span id='global-method-addHoverVectorLayerInteraction'>    /**
</span>     *
     */
    addHoverVectorLayerInteraction: function () {
        var me = this;
        var mapComponent = me.getCmp();
        var map = mapComponent.getMap();

        if (!me.getHoverVectorLayerInteraction()) {
            var interaction = new ol.interaction.Select({
                multi: me.selectMulti,
                style: me.selectStyleFunction,
                layers: [me.getHoverVectorLayer()],
                filter: me.clickable ? me.filterClickableFeatures : undefined
            });
            if (me.selectEventOrigin === &#39;collection&#39;) {
                var featureCollection = interaction.getFeatures();
                featureCollection.on(&#39;add&#39;, me.onFeatureClicked.bind(me));
            } else {
                interaction.on(&#39;select&#39;, me.onFeatureClicked.bind(me));
            }
            map.addInteraction(interaction);
            me.setHoverVectorLayerInteraction(interaction);
        }
    },

<span id='global-method-onFeatureClicked'>    /**
</span>     * Overwrites the hover.js onFeatureClicked method to
     * a noop method, as this function does not fit into
     * the hoverClick concept with separate workflows
     * for hovering and clicking.
     *
     * @return {undefined}
     */
    onFeatureClicked: function () {
        return;
    },

<span id='global-method-filterClickableFeatures'>    /**
</span>     * Filters the clickable features by checking the
     * isClickable property.
     *
     * @param {ol.feature} feature the feature to check.
     * @return {Boolean} Whether the feature is clickable.
     */
    filterClickableFeatures: function (feature) {
        return feature.isClickable;
    },

<span id='global-method-onClick'>    /**
</span>     * The handler for the click event on the map.
     *
     * @param {MouseEvent.onClick} evt The onClick event
     */
    onClick: function (evt) {

        var me = this;

        if (!me.getClickActive()) {
            return;
        }

        var mapComponent = me.getCmp();
        var map = mapComponent.getMap();
        var mapView = map.getView();
        var allLayers = map.getAllLayers();
        var pixel = evt.pixel;
        var hoverFeaturesRevertProp = me.self.LAYER_HOVER_FEATURES_REVERT_NAME;
        var clickableProp = me.self.LAYER_CLICKABLE_PROPERTY_NAME;
        var hoverLayers = [];
        var hoverFeatures = [];

        me.cleanupHoverArtifacts();

        var callback = function(layer, pixelValues) {
            if (!layer.get(clickableProp)) {
                return;
            }

            var source = layer.getSource();
            var resolution = mapView.getResolution();
            var projCode = mapView.getProjection().getCode();
            var hoverFeaturesRevert = layer.get(hoverFeaturesRevertProp);

            if (source instanceof ol.source.TileWMS
                    || source instanceof ol.source.ImageWMS) {

                var url = source.getFeatureInfoUrl(
                    evt.coordinate,
                    resolution,
                    projCode,
                    {
                        &#39;INFO_FORMAT&#39;: &#39;application/json&#39;,
                        &#39;FEATURE_COUNT&#39;: me.getFeatureInfoCount()
                    }
                );

                me.requestAsynchronously(url, function(resp) {
                    // TODO: replace evt/coords with real response geometry
                    var respFeatures = (new ol.format.GeoJSON())
                        .readFeatures(resp.responseText);
                    var respProjection = (new ol.format.GeoJSON())
                        .readProjection(resp.responseText);

                    me.showHoverFeature(
                        layer, respFeatures, respProjection
                    );

                    Ext.each(respFeatures, function(feature) {
                        feature.set(&#39;layer&#39;, layer);
                        var featureStyle = me.highlightStyleFunction(
                            feature, resolution, pixelValues);
                        feature.setStyle(featureStyle);
                        hoverFeatures.push(feature);
                    });
                    if (hoverFeaturesRevert) {
                        hoverFeatures.reverse();
                    }

                    hoverLayers.push(layer);
                    mapComponent.fireEvent(&#39;hoverfeaturesclick&#39;, hoverFeatures);
                });
            } else if (source instanceof ol.source.Vector) {
                // VECTOR!
                map.forEachFeatureAtPixel(pixel, function(feat) {
                    if (layer.get(&#39;type&#39;) === &#39;WFS&#39; ||
                            layer.get(&#39;type&#39;) === &#39;WFSCluster&#39;) {
                        var hvl = me.getHoverVectorLayer();
                        // TODO This should be dynamically generated
                        // from the clusterStyle
                        hvl.setStyle(me.highlightStyleFunction);
                    }
                    if (!Ext.Array.contains(hoverLayers, layer)) {
                        hoverLayers.push(layer);
                    }
                    if (feat.get(&#39;layer&#39;) === layer) {
                        var clone = feat.clone();
                        clone.setId(feat.getId());

                        var hoverFeaturesIds = Ext.Array.map(hoverFeatures,
                            function(hoverFeat) {
                                return hoverFeat.getId();
                            });
                        if (!Ext.Array.contains(hoverFeaturesIds,
                            feat.getId())) {
                            var style = me.highlightStyleFunction(
                                clone, resolution, pixel);
                            clone.setStyle(style);
                            hoverFeatures.push(clone);
                        }
                    }
                    me.showHoverFeature(layer, hoverFeatures);
                    me.currentHoverTarget = feat;
                    mapComponent.fireEvent(&#39;hoverfeaturesclick&#39;, hoverFeatures);
                }, {
                    layerFilter: function(vectorCand) {
                        return vectorCand === layer;
                    }
                });
            }
        };

        allLayers.forEach(function(lyr) {
            var layerData = lyr.getData(pixel);
            if (layerData) {
                var alphaValue = layerData.at(3);
                if (alphaValue &gt; 0 &amp;&amp; me.clickLayerFilter(lyr)) {
                    callback(lyr, layerData);
                }
            }
        });

    },

<span id='global-method-clickLayerFilter'>    /**
</span>     * @param {ol.layer.Base} candidate The layer to check.
     * @return {Boolean} Whether the passed layer should be clickable.
     */
    clickLayerFilter: function (candidate) {
        var me = this;
        var clickableProp = me.self.LAYER_CLICKABLE_PROPERTY_NAME;

        if (candidate.get(clickableProp) ||
                candidate.get(&#39;type&#39;) === &#39;WFSCluster&#39;) {
            return true;
        } else {
            return false;
        }
    },

<span id='global-method-showHoverFeature'>    /**
</span>     * Adds the passed features to the hover vector layer.
     *
     * @param {ol.layer.Layer} layer The layer. Currently unused in the method.
     * @param {Array&lt;ol.Feature&gt;} features The features to hover by adding them
     *     to the source of the hover vector layer.
     * @param {ol.Projection} projection The projection of the features.
     */
    showHoverFeature: function(layer, features, projection) {
        var me = this;
        var mapComponent = me.getCmp();
        var map = mapComponent.getMap();
        var proj = me.getFeatureInfoEpsg();
        var clickableProp = me.self.LAYER_CLICKABLE_PROPERTY_NAME;
        var clickable = layer.get(clickableProp);

        if (projection) {
            proj = projection;
        }
        var source = me.getHoverVectorLayerSource();
        Ext.each(features, function(feat) {
            feat.isClickable = clickable;
            var g = feat.getGeometry();
            if (g) {
                g.transform(proj, map.getView().getProjection());
            }
            if (!Ext.Array.contains(source.getFeatures(),
                feat)) {
                source.addFeature(feat);
            }
        });
    }

});
</pre>
</body>
</html>
