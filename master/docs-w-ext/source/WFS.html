<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* Copyright (c) 2016-present terrestris GmbH &amp; Co. KG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
<span id='BasiGX-util-WFS'>/**
</span> * WFS utility.
 *
 * @class BasiGX.util.WFS
 */
Ext.define(&#39;BasiGX.util.WFS&#39;, {

    requires: [
        &#39;BasiGX.util.CSRF&#39;,
        &#39;BasiGX.util.Filter&#39;,
        &#39;BasiGX.util.Jsonix&#39;,
        &#39;BasiGX.util.Namespace&#39;,
        &#39;BasiGX.util.Object&#39;,
        &#39;BasiGX.util.Url&#39;
    ],

    inheritableStatics: {

<span id='BasiGX-util-WFS-static-property-errorMsgTitle'>        /* start i18n*/
</span>        errorMsgTitle: &#39;&#39;,
<span id='BasiGX-util-WFS-static-property-wfsExecuteExceptionText'>        wfsExecuteExceptionText: &#39;&#39;,
</span>        /* end i18n*/

<span id='BasiGX-util-WFS-static-property-reMatchFilter'>        /**
</span>         * A regular expression that will match an OGC `&lt;ogc:Filter&gt;` element.
         * Captured parts are as follows:
         *
         * * Index `0`: Complete match.
         * * Index `1`: `&lt;ogc:Filter&gt;` start tag including attributes, if any.
         *   Will also match non-prefixed variant `&lt;Filter&gt;`
         * * Index `2`: Anything between `&lt;ogc:Filter&gt;` start and end tag.
         * * Index `3`: `&lt;/ogc:Filter&gt;` end tag.  Will also match
         *   non-prefixed variant `&lt;/Filter&gt;`
         *
         * Hat-tip: http://www.regular-expressions.info/examples.html
         */
        reMatchFilter: /(&lt;(?:ogc:)?Filter\b[^&gt;]*&gt;)(.*?)(&lt;\/(?:ogc:)?Filter&gt;)/,

<span id='BasiGX-util-WFS-static-property-wfsGetFeatureXmlTpl'>        /**
</span>         * The WFS GetFeature XML body template
         */
        wfsGetFeatureXmlTpl: &#39;&#39; +
            &#39;&lt;wfs:GetFeature service=&quot;WFS&quot; version=&quot;1.1.0&quot;&#39; +
                &#39; outputFormat=&quot;JSON&quot;&#39; +
                &#39; maxFeatures=&quot;{6}&quot;&#39; +
                &#39; viewParams=&quot;{7}&quot;&#39; +
                // {0} is replaced with namespace alias,
                // {1} with namespace URI
                &#39; xmlns:{0}=&quot;{1}&quot;&#39; +
                &#39; xmlns:wfs=&quot;http://www.opengis.net/wfs&quot;&#39; +
                &#39; xmlns=&quot;http://www.opengis.net/ogc&quot;&#39; +
                &#39; xmlns:gml=&quot;http://www.opengis.net/gml&quot;&#39; +
                &#39; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#39; +
                &#39; xsi:schemaLocation=&quot;http://www.opengis.net/wfs&#39; +
                &#39; http://schemas.opengis.net/wfs/1.0.0/WFS-basic.xsd&quot;&gt;&#39; +
                // {2} is replaced with qualified featuretype
                &#39;&lt;wfs:Query typeName=&quot;{2}&quot; srsName=&quot;{3}&quot;&gt;&#39; +
                    &#39;{4}&#39; + // eventually also multiple times for multiple atts:
                    // &#39;&lt;wfs:PropertyName&gt;attname&lt;/wfs:PropertyName&gt;&#39;
                    // {5} is replaced with actual filter
                    &#39;{5}&#39; + // Filter
                &#39;&lt;/wfs:Query&gt;&#39; +
            &#39;&lt;/wfs:GetFeature&gt;&#39;,

<span id='BasiGX-util-WFS-static-method-getBboxFilter'>        /**
</span>         * Returns a BBOX filter for the given map and the passed property name.
         *
         * Implementation very likely to change using Jsonix.
         *
         * @param {ol.Map} map The map to get the extent from.
         * @param {String} propertyName The name of the geometry property of the
         *     featuretype to filter.
         * @param {Array} extent The optional extent Array to use for the filter
         * @param {String} type The type of the filter to create, can either be
         *     `&#39;bbox&#39;`, `&#39;intersects&#39;` or `&#39;both&#39;` (the default). Strings other
         *     than the beforementioned will be interpreted as `&#39;both&#39;`.
         * @return {String} The create BBOX filter.
         */
        getBboxFilter: function(map, propertyName, extent, type) {
            type = type ? (type + &#39;&#39;).toLowerCase() : &#39;both&#39;;
            type = (type === &#39;bbox&#39; || type === &#39;intersects&#39;) ? type : &#39;both&#39;;
            var filters = [];
            if (type === &#39;bbox&#39; || type === &#39;both&#39;) {
                filters.push(
                    &#39;  &lt;ogc:BBOX&gt;&#39; +
                    &#39;    &lt;ogc:PropertyName&gt;{0}&lt;/ogc:PropertyName&gt;&#39; +
                    &#39;    &lt;gml:Envelope&#39; +
                    &#39; xmlns:gml=&quot;http://www.opengis.net/gml&quot; srsName=&quot;{1}&quot;&gt;&#39; +
                    &#39;      &lt;gml:lowerCorner&gt;{2} {3}&lt;/gml:lowerCorner&gt;&#39; +
                    &#39;      &lt;gml:upperCorner&gt;{4} {5}&lt;/gml:upperCorner&gt;&#39; +
                    &#39;    &lt;/gml:Envelope&gt;&#39; +
                    &#39;  &lt;/ogc:BBOX&gt;&#39;
                );
            }
            if (type === &#39;intersects&#39; || type === &#39;both&#39;) {
                filters.push(
                    &#39;  &lt;ogc:Intersects&gt;&#39; +
                    &#39;    &lt;ogc:PropertyName&gt;{0}&lt;/ogc:PropertyName&gt;&#39; +
                    &#39;    &lt;gml:Envelope&#39; +
                    &#39; xmlns:gml=&quot;http://www.opengis.net/gml&quot; srsName=&quot;{1}&quot;&gt;&#39; +
                    &#39;      &lt;gml:lowerCorner&gt;{2} {3}&lt;/gml:lowerCorner&gt;&#39; +
                    &#39;      &lt;gml:upperCorner&gt;{4} {5}&lt;/gml:upperCorner&gt;&#39; +
                    &#39;    &lt;/gml:Envelope&gt;&#39; +
                    &#39;  &lt;/ogc:Intersects&gt;&#39;
                );
            }

            var tpl = BasiGX.util.WFS.combineFilters(filters, &#39;And&#39;, &#39;&#39;);
            var mapView = map.getView();
            var srsName = mapView.getProjection().getCode();
            if (!extent) {
                extent = mapView.calculateExtent(map.getSize());
            }
            var filter = Ext.String.format(
                tpl,
                propertyName,
                srsName,
                extent[0], extent[1],
                extent[2], extent[3]
            );
            return filter;
        },
<span id='BasiGX-util-WFS-static-method-getAttributeLikeFilter'>        /**
</span>         * Returns a attribute LIKE filter for the passed property names. Can be
         * combined with `Or` (default) or `And` operator.
         *
         * @param {Array} propertyNames The name of the properties which should
         * be queried.
         * @param {String} queryValue The value to query.
         * @param {String} combinator Should be either `And` or `Or`.
         * @param {Boolean} matchCase If the case should be considered.
         *   Default is false.
         * @param {String} namespace Namespace alias for the XML to be used as
         *   prefix for `PropertyIsLike` filter. Optional. Default is `ogc`.
         * @return {String} The created LIKE filter.
         */
        getAttributeLikeFilter: function(propertyNames, queryValue, combinator,
            matchCase, namespace) {
            var defaultCombineWith = &#39;Or&#39;;
            var defaultMatchCase = false;

            var ogcNs = namespace || &#39;ogc&#39;;
            ogcNs += &#39;:&#39;;

            var combineWith = combinator || defaultCombineWith;
            var match = matchCase || defaultMatchCase;

            var tpl = &#39;&#39; +
                &#39; &lt;PropertyIsLike wildCard=&quot;*&quot; singleChar=&quot;.&quot;&#39; +
                &#39; escape=&quot;!&quot; matchCase=&quot;&#39; + match + &#39;&quot;&gt;&#39; +
                &#39;      &lt;PropertyName&gt;{0}&lt;/PropertyName&gt;&#39; +
                &#39;      &lt;Literal&gt;*{1}*&lt;/Literal&gt;&#39; +
                &#39;  &lt;/PropertyIsLike&gt;&#39;;

            var filter = &#39;&lt;&#39;+ ogcNs + combineWith + &#39;&gt;&#39;;
            Ext.each(propertyNames, function(propertyName) {
                filter += Ext.String.format(
                    tpl,
                    propertyName,
                    queryValue
                );
            });
            filter += &#39;&lt;/&#39; + ogcNs + combineWith + &#39;&gt;&#39;;
            return filter;
        },

<span id='BasiGX-util-WFS-static-method-getOgcFromCqlFilter'>        /**
</span>         * Returns an OGC filter for the given CQL Filter.
         * Support for different filters is currently very limited.
         * Only CQL filters having a key, operator and value are supported
         * for now.
         *
         * @param {String} cqlFilter The CQL filter to convert
         * @return {String} The OGC filter.
         */
        getOgcFromCqlFilter: function(cqlFilter) {
            if (!cqlFilter) {
                return;
            }
            var parts = /^\s*([\w_]+)\s*([&lt;&gt;=!]+|in|like)\s*([^\s]+)\s*$/gi
                .exec(cqlFilter);
            if (!parts || parts.length !== 4) {
                Ext.log.error(&#39;Method `getOgcFromCqlFilter` can only handle &#39; +
                &#39;CQL filters with one key, one operator and one value!&#39;);
                return;
            }

            var key = parts[1];
            var operator = parts[2].toLowerCase();
            var value = parts[3];
            var ogcFilterType;
            var closingTag;

            // always replace surrounding quotes
            value = value.replace(/(^[&#39;])/g, &#39;&#39;);
            value = value.replace(/([&#39;]$)/g, &#39;&#39;);

            switch (operator) {
                case &#39;=&#39;:
                    ogcFilterType = &#39;PropertyIsEqualTo&#39;;
                    break;
                case &#39;!=&#39;:
                    ogcFilterType = &#39;PropertyIsNotEqualTo&#39;;
                    break;
                case &#39;&lt;&#39;:
                    ogcFilterType = &#39;PropertyIsLessThan&#39;;
                    break;
                case &#39;&gt;&#39;:
                    ogcFilterType = &#39;PropertyIsGreaterThan&#39;;
                    break;
                case &#39;&lt;=&#39;:
                    ogcFilterType = &#39;PropertyIsLessThanOrEqualTo&#39;;
                    break;
                case &#39;&gt;=&#39;:
                    ogcFilterType = &#39;PropertyIsGreaterThanOrEqualTo&#39;;
                    break;
                case &#39;like&#39;:
                    ogcFilterType = &#39;PropertyIsLike&#39;;
                    value = &#39;%&#39; + value + &#39;%&#39;;
                    break;
                case &#39;in&#39;:
                    ogcFilterType = &#39;Or&#39;;
                    // cleanup brackets and quotes
                    value = value.replace(/([()&#39;])/g, &#39;&#39;);
                    var values = value.split(&#39;,&#39;);
                    var filters = &#39;&#39;;
                    Ext.each(values, function(val) {
                        filters +=
                            &#39;&lt;ogc:PropertyIsEqualTo&gt;&#39; +
                            &#39;&lt;ogc:PropertyName&gt;&#39; + key + &#39;&lt;/ogc:PropertyName&gt;&#39; +
                            &#39;&lt;ogc:Literal&gt;&#39; + val + &#39;&lt;/ogc:Literal&gt;&#39; +
                            &#39;&lt;/ogc:PropertyIsEqualTo&gt;&#39;;
                    });
                    ogcFilterType = &#39;&lt;ogc:&#39; + ogcFilterType + &#39;&gt;&#39;;
                    closingTag = Ext.String.insert(ogcFilterType, &#39;/&#39;, 1);
                    return ogcFilterType + filters + closingTag;
                default:
                    Ext.log.warn(&#39;Method `getOgcFromCqlFilter` could not &#39; +
                        &#39;handle the given operator: &#39; + operator);
                    return;
            }
            ogcFilterType = &#39;&lt;ogc:&#39; + ogcFilterType + &#39;&gt;&#39;;
            closingTag = Ext.String.insert(ogcFilterType, &#39;/&#39;, 1);
            var tpl = &#39;&#39; +
                &#39;  {0}&#39; +
                &#39;    &lt;ogc:PropertyName&gt;{1}&lt;/ogc:PropertyName&gt;&#39; +
                &#39;    &lt;ogc:Literal&gt;{2}&lt;/ogc:Literal&gt;&#39; +
                &#39;  {3}&#39;;

            var filter = Ext.String.format(
                tpl,
                ogcFilterType,
                key,
                value,
                closingTag
            );
            return filter;
        },

<span id='BasiGX-util-WFS-static-method-getTimeFilterParts'>        /**
</span>         * Returns an OGC `PropertyIsLessThanOrEqualTo` and
         * `PropertyIsGreaterThanOrEqualTo` filters with the current TIME taken
         * from the layer source and the given dimensionAttribute
         *
         * @param {ol.layer.Base} layer The layer to get the filter for.
         * @param {String} dimensionAttribute The dimensionAttribute
         *   containing the comma separated start / end keys for WMS TIME
         * @param {String} timeParamFallback The time parameter fallback string
         * @return {Array&lt;String&gt;} An Array containing OGC
         *   `PropertyIsLessThanOrEqualTo` and  `PropertyIsGreaterThanOrEqualTo`
         *   filters regarding to the current TIME taken from the layer source
         *   and set net definition.
         */
        getTimeFilterParts: function(layer, dimensionAttribute,
            timeParamFallback) {

            if (!dimensionAttribute) {
                return;
            }

            var dimensionAttributes = dimensionAttribute.split(&#39;,&#39;);
            if (dimensionAttributes.length === 1) {
                dimensionAttributes.push(dimensionAttributes[0]);
            }

            var source = layer.getSource();
            var params = source &amp;&amp; source.getParams &amp;&amp; source.getParams();
            var timeParam = params &amp;&amp; params.TIME;
            if (!timeParam &amp;&amp; !timeParamFallback) {
                return;
            }
            timeParam = timeParam || timeParamFallback;

            var timeParts = timeParam.split(&#39;/&#39;);
            var lowerBoundary = timeParts[0];
            var upperBoundary = timeParts[1];
            if (timeParts.length === 1) {
                upperBoundary = timeParts[0];
            }

            // possibly smallest time range value
            var lowerBoundaryTpl = &#39;&lt;ogc:PropertyIsGreaterThanOrEqualTo&gt;&#39; +
                &#39;&lt;ogc:PropertyName&gt;{0}&lt;/ogc:PropertyName&gt;&#39; +
                &#39;&lt;ogc:Literal&gt;{1}&lt;/ogc:Literal&gt;&#39; +
                &#39;&lt;/ogc:PropertyIsGreaterThanOrEqualTo&gt;&#39;;

            // possibly biggest time range value
            var upperBoundaryTpl = &#39;&lt;ogc:PropertyIsLessThanOrEqualTo&gt;&#39; +
                &#39;&lt;ogc:PropertyName&gt;{0}&lt;/ogc:PropertyName&gt;&#39; +
                &#39;&lt;ogc:Literal&gt;{1}&lt;/ogc:Literal&gt;&#39; +
                &#39;&lt;/ogc:PropertyIsLessThanOrEqualTo&gt;&#39;;

            var lowerBoundaryFilter = Ext.String.format(
                lowerBoundaryTpl,
                Ext.String.trim(dimensionAttributes[1]),
                lowerBoundary
            );

            var upperBoundaryFilter = Ext.String.format(
                upperBoundaryTpl,
                Ext.String.trim(dimensionAttributes[0]),
                upperBoundary
            );

            return [lowerBoundaryFilter, upperBoundaryFilter];
        },

<span id='BasiGX-util-WFS-static-method-unwrapFilter'>        /**
</span>         * Returns the contents of filter with the outermost `&lt;ogc:Filter&gt;` or
         * `&lt;Filter&gt;` removed.
         *
         * @param {String} filter The filter to remove `&lt;ogc:Filter&gt;` /
         *     `&lt;Filter&gt;` from.
         * @return {String} The contents of the filter.
         */
        unwrapFilter: function(filter) {
            var regex = BasiGX.util.WFS.reMatchFilter;
            var matches = filter.match(regex);
            if (!matches || matches.length !== 4) {
                return filter;
            }
            return matches[2];
        },

<span id='BasiGX-util-WFS-static-method-getFilterPrefix'>        /**
</span>         * Returns the actually used `&lt;ogc:Filter&gt;` / `&lt;Filter&gt;` start tag
         * from the passed OGC filter.
         *
         * @param {String} filter The filter to get the `&lt;ogc:Filter&gt;` /
         *     `&lt;Filter&gt;` from.
         * @return {String} The `&lt;ogc:Filter&gt;` / `&lt;Filter&gt;` of the filter or
         *     the empty string.
         */
        getFilterPrefix: function(filter) {
            var regex = BasiGX.util.WFS.reMatchFilter;
            var matches = filter.match(regex);
            if (!matches || matches.length !== 4) {
                return &#39;&#39;;
            }
            return matches[1];
        },

<span id='BasiGX-util-WFS-static-method-combineFilters'>        /**
</span>         * Combines the passed filters with an `&lt;ogc:And&gt;` or `&lt;ogc:Or&gt;` and
         * returns them.
         *
         * @param {Array&lt;String&gt;} filters The filters to join, falsy ones will
         *     be skipped.
         * @param {String} [combinator] The boolean combinator to use, should be
         *     either `And` (the default) or `Or`.
         * @param {String} [filterTag] The tag which should be used at the begin
         *     of the filter string. If you pass the empty string (`&#39;&#39;`), the
         *     combined filters will not be wrapped in an `&lt;ogc:Filter&gt;`.
         * @return {String} An combined OGC filter with the passed filters.
         */
        combineFilters: function(filters, combinator, filterTag) {
            var ogcNsUri = &#39;http://www.opengis.net/ogc&#39;;
            var defaultStartTag = &#39;&lt;ogc:Filter xmlns:ogc=&quot;&#39; + ogcNsUri + &#39;&quot;&gt;&#39;;
            var defaultCombineWith = &#39;And&#39;;
            var truthyFilters = Ext.Array.filter(filters, function(filter) {
                return !!filter;
            });
            var numFilters = truthyFilters.length;

            var combineWith = combinator || defaultCombineWith;
            var startFilterTag;
            if (Ext.isDefined(filterTag)) {
                startFilterTag = filterTag;
            } else {
                startFilterTag = defaultStartTag;
            }

            var parts = [];
            parts.push(startFilterTag);

            if (numFilters &gt; 1) {
                parts.push(&#39;&lt;ogc:&#39; + combineWith + &#39;&gt;&#39;);
            }

            Ext.each(truthyFilters, function(filter) {
                parts.push(filter);
            });

            if (numFilters &gt; 1) {
                parts.push(&#39;&lt;/ogc:&#39; + combineWith + &#39;&gt;&#39;);
            }

            if (startFilterTag !== &#39;&#39;) {
                parts.push(&#39;&lt;/ogc:Filter&gt;&#39;);
            }
            return parts.join(&#39;&#39;);
        },

<span id='BasiGX-util-WFS-static-method-insertFilter'>        /**
</span>         * Combines all configured filters (e.g. spatial and time filter) to
         * one filter string and returns them.
         *
         * @param {Array&lt;String&gt;} filter Given full spatial filter string.
         * @param {String} [combinator] The boolean combinator to use, should be
         *     either `And` or `Or`.
         * @param {String} additionalFilter Additional filter (e.g. time filter)
         *     that should be added to the given filter.
         * @return {String} An OGC And filter with the passed filters.
         */
        insertFilter: function(filter, combinator, additionalFilter) {

            var regex = BasiGX.util.WFS.reMatchFilter;
            var matches = filter.match(regex);
            if (!matches || matches.length !== 4) {
                return filter;
            }
            var allFilters = [];
            var filterStart = matches[1];
            var existingFilter = matches[2];

            allFilters.push(existingFilter);
            Ext.Array.each(additionalFilter, function(af) {
                allFilters.push(af);
            });

            var combined = this.combineFilters(
                allFilters,
                combinator,
                filterStart
            );
            return combined;
        },

<span id='BasiGX-util-WFS-static-method-executeWfsGetFeature'>        /**
</span>         * Executes a WFS GetFeature request for the passed arguments.
         *
         * TODO Refactor so this doesn&#39;t need that much arguments.
         *
         * @param {String} url The URL to the geoserver WFS endpoint
         * @param {ol.layer.Base} layer The layer to query
         * @param {String} srsName The name of the SRS to reporject features to
         * @param {Array} displayColumns The array of columns to display
         * @param {String} geomFieldName The name of the geom field
         * @param {String} filter An OGC 1.1.0 filter in XML format for limiting
         *    the number of returned features.
         * @param {Integer} maxFeatures The maximum number of features to get.
         *    Defaults to 1000 if not set.
         * @param {Function} successCallback A function to call with the
         *    response in case the request finished successfully.
         * @param {Function} failureCallback A function to call with the
         *    response in case the request finished with an error.
         * @param {Object} scope The scope (this-context) of the methods for
         *    success or failure callbacks.
         * @param {String} viewParams the view params to append
         * @param {String} featureType the feature type to query
         * @return {Ext.data.request.Ajax} The request object.
         */
        executeWfsGetFeature: function(url, layer, srsName, displayColumns,
            geomFieldName, filter, maxFeatures, successCallback,
            failureCallback, scope, viewParams, featureType) {
            if (!viewParams) {
                viewParams = &#39;&#39;;
            }

            if (!featureType) {
                var params = layer.getSource().getParams();
                featureType = BasiGX.util.Object.layersFromParams(params);
            }

            var ns = featureType.split(&#39;:&#39;)[0];
            var namespaceUtil = BasiGX.util.Namespace;
            var nsUri = namespaceUtil.namespaceUriFromNamespace(ns);

            var staticMe = BasiGX.util.WFS;

            var propertyNameXml = &#39;&#39;;
            var propNameTpl = &#39;&lt;wfs:PropertyName&gt;{0}&lt;/wfs:PropertyName&gt;&#39;;

            if (!Ext.isEmpty(displayColumns)) {
                Ext.each(displayColumns, function(col) {
                    propertyNameXml += Ext.String.format(propNameTpl, col);
                });

                if (!geomFieldName) {
                    geomFieldName = &#39;geom&#39;; // just a default
                }

                propertyNameXml +=
                    Ext.String.format(propNameTpl, geomFieldName);
            }

            if (!maxFeatures) {
                maxFeatures = 1000;
            }

            var xml = Ext.String.format(
                staticMe.wfsGetFeatureXmlTpl,
                ns,
                nsUri,
                featureType,
                srsName,
                propertyNameXml,
                filter, // OGC 1.1.0. filter as string
                maxFeatures,
                viewParams
            );

            return Ext.Ajax.request({
                headers: BasiGX.util.CSRF.getHeader(),
                url: url,
                method: &#39;POST&#39;,
                xmlData: xml,
                success: successCallback,
                failure: failureCallback,
                scope: scope
            });
        },

<span id='BasiGX-util-WFS-static-method-genericSuccessHandler'>        /**
</span>         * A generic function bound as the success callback, if none was
         * provided.
         */
        genericSuccessHandler: function() {
            Ext.log.info(&#39;WFS GetFeature executed.&#39;);
        },

<span id='BasiGX-util-WFS-static-method-genericFailureHandler'>        /**
</span>         * A generic function bound as the failure callback, if none was
         * provided.
         */
        genericFailureHandler: function() {
            Ext.log.warn(&#39;Failed to execute WFS GetFeature.&#39;);
        },

<span id='BasiGX-util-WFS-static-method-handleWfsExecuteException'>        /**
</span>         * If WFS request was successful but response has got an exception,
         * we try to find it out and show the corresponding error message
         *
         * @param {Object} response The response of the Ajax call.
         */
        handleWfsExecuteException: function(response) {
            var staticMe = BasiGX.util.WFS;
            var util = BasiGX.util.Jsonix;
            var parsedXml = util.unmarshaller.unmarshalString(response);
            if (parsedXml &amp;&amp; parsedXml.value &amp;&amp; parsedXml.value.exception[0]) {
                var excReport = parsedXml.value.exception[0];
                var excCode = excReport.exceptionCode;
                var excMsg = excReport.exceptionText[0];
                var excTitlePrefix = staticMe.errorMsgTitle;
                var excTitle = excTitlePrefix + &#39;: &#39; + excCode;
                BasiGX.util.MsgBox.error(
                    Ext.String.format(
                        staticMe.wfsExecuteExceptionText,
                        excMsg
                    ),
                    {title: excTitle}
                );
            }
        },

<span id='BasiGX-util-WFS-static-method-getFullFilterAndApplyIt'>        /**
</span>         * Builds the full filter encoding object from all given filters
         * (spatial, time and SLD) and sends it as parameter for the WFS
         * GetFeature request for selection.
         *
         * Suppose you have the following filters:
         *
         * * `spatialFilter`, let&#39;s call this `F1`
         * * `timeFilter`, call this `F2`
         * * `sldFilters`, an array of `F3` and `F4`
         *
         * This method will combine these filters as follows:
         *
         *     F1    AND    F2    AND    (  F3    OR    F4  )
         *
         * @param {ol.layer.Base} filterLayer The layer to handle
         * @param {String} spatialFilter Filter encoding for spatial filter.
         * @param {String} timeFilterParts Filter encoding for time filter
         *     containing two OGC filters - `PropertyIsGreaterThanOrEqualTo` and
         *     `PropertyIsLessThanOrEqualTo`.
         * @param {Array} sldFilters Array containing filter encodings for SLD
         *     filters.
         * @param {Function} successCallback A function to call with the
         *     response in case the request finished successfully.
         * @param {Function} failureCallback A function to call with the
         *     response in case the request finished with an error.
         * @param {Object} scope The scope (this-context) of the methods for
         *     success or failure callbacks.
         */
        getFullFilterAndApplyIt: function(filterLayer, spatialFilter,
            timeFilterParts, sldFilters, successCallback, failureCallback,
            scope) {
            var staticMe = BasiGX.util.WFS;
            var spatialTimeFilterPart = staticMe.insertFilter(
                spatialFilter, &#39;And&#39;, timeFilterParts
            );
            var mapComponent = BasiGX.util.Map.getMapComponent();
            var srs = mapComponent.map.getView().getProjection().getCode();

            var layerSource = filterLayer.getSource();
            var url;

            if (layerSource instanceof ol.source.TileWMS) {
                url = layerSource.getUrls()[0];
            } else if (layerSource instanceof ol.source.ImageWMS) {
                url = layerSource.getUrl();
            } else {
                return;
            }

            var filter = spatialTimeFilterPart; // fallback
            filter = staticMe.mergeFilterWithSldFilters(filter, sldFilters);

            if (!Ext.isEmpty(filter)) {
                mapComponent.setLoading(true);

                var displayColumns = filterLayer.get(&#39;displayColumns&#39;);
                var geomFieldName = filterLayer.get(&#39;geomFieldName&#39;);

                staticMe.executeWfsGetFeature(
                    url,
                    filterLayer,
                    srs,
                    displayColumns,
                    geomFieldName,
                    filter,
                    null,
                    successCallback,
                    failureCallback,
                    scope,
                    null
                );
            }
        },

<span id='BasiGX-util-WFS-static-method-getTimeAndSldCompliantFilter'>        /**
</span>         * This function will return a filter string containing a bbox filter,
         * the passed sldFilters and a possible time filter (if the layer is
         * configured as WMS-T).
         *
         * @param {ol.layer.Base} layer The layer to get the filter for.
         * @param {String} dimensionAttribute The dimensionAttribute
         *      containing the comma separated start / end keys for WMS TIME
         * @param {Array} sldFilters An array of filter strings coming
         *   from the SLD.
         * @param {ol.Map} map optional map parameter. Will be guessed if
         *   not passed.
         * @param {String} geomFieldName The name of the geom field
         * @param {Array} extent The optional extent Array to use for the bbox
         *    filter
         * @return {String} filter string as described above
         */
        getTimeAndSldCompliantFilter: function(
            layer, dimensionAttribute, sldFilters, map, geomFieldName, extent) {
            var staticMe = BasiGX.util.WFS;

            // guess the map if it has not been passed
            if (!map) {
                map = BasiGX.util.Map.getMapComponent().map;
            }

            var allFilters = [];
            var timeFilterParts = staticMe.getTimeFilterParts(
                layer, dimensionAttribute);
            if (timeFilterParts) {
                allFilters = timeFilterParts;
            }
            if (extent) {
                var bboxFilter = staticMe.getBboxFilter(
                    map,
                    geomFieldName,
                    extent
                );
                allFilters.push(bboxFilter);
            }

            var filter = staticMe.combineFilters(allFilters);

            return staticMe.mergeFilterWithSldFilters(filter, sldFilters);
        },

<span id='BasiGX-util-WFS-static-method-mergeFilterWithSldFilters'>        /**
</span>         * Merge the passed &quot;base&quot; filter with the passed sld filters.
         *
         * @param {String} filter string representing some &quot;base&quot; filter
         *   (e.g. time/spatial)
         * @param {Array} sldFilters An array of filter strings coming
         *   from the SLD.
         *
         * @return {String} filter string representing the merge of the passed
         *   filter with the passed sld filters
         */
        mergeFilterWithSldFilters: function(filter, sldFilters) {
            var staticMe = BasiGX.util.WFS;
            var plainSldFilters = [];
            Ext.each(sldFilters, function(sldFilter) {
                plainSldFilters.push(staticMe.unwrapFilter(sldFilter));
            });

            if (plainSldFilters.length &gt; 0) {
                // we had some SLD filters, and need to add them to the
                // existing one
                var orCombinedSldFilter = staticMe.combineFilters(
                    plainSldFilters, &#39;Or&#39;, &#39;&#39;
                );
                filter = staticMe.insertFilter(
                    filter, &#39;And&#39;, orCombinedSldFilter
                );
            }
            return filter;
        }
    }
});
</pre>
</body>
</html>
