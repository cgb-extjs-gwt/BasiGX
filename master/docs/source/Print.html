<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* Copyright (c) 2015-present terrestris GmbH &amp; Co. KG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
<span id='BasiGX-view-form-Print'>/**
</span> * Print FormPanel
 *
 * Used to show an Mapfish Print v3 compatible print panel
 *
 * @class BasiGX.view.form.Print
 */
Ext.define(&#39;BasiGX.view.form.Print&#39;, {
    extend: &#39;Ext.form.Panel&#39;,
    xtype: &#39;basigx-form-print&#39;,

    requires: [
        &#39;Ext.window.Toast&#39;,
        &#39;Ext.app.ViewModel&#39;,
        &#39;Ext.form.action.StandardSubmit&#39;,

        &#39;BasiGX.util.Layer&#39;,
        &#39;BasiGX.util.Map&#39;,
        &#39;BasiGX.olExt.TransformInteraction&#39;,

        &#39;GeoExt.data.MapfishPrintProvider&#39;
    ],
    statics: {
<span id='BasiGX-view-form-Print-static-property-LAYER_IDENTIFIER_KEY'>        LAYER_IDENTIFIER_KEY: &#39;_basigx_printextent_layer_&#39;
</span>    },
<span id='BasiGX-view-form-Print-property-defaultListenerScope'>    defaultListenerScope: true,
</span>
<span id='BasiGX-view-form-Print-property-viewModel'>    viewModel: {
</span>        data: {
            title: &#39;Drucken&#39;,
            labelDpi: &#39;DPI&#39;,
            printButtonSuffix: &#39;anfordern&#39;,
            downloadButtonPrefix: &#39;Download&#39;,
            printFormat: &#39;pdf&#39;,
            printAppFieldSetTitle: &#39;Vorlage&#39;,
            genericFieldSetTitle: &#39;Einstellungen&#39;,
            formatComboLabel: &#39;Format&#39;,
            layoutComboLabel: &#39;Layout&#39;,
            attributesTitle: &#39;Eigenschaften&#39;,
            mapTitleLabel: &#39;Kartentitel&#39;,
            documentation: &#39;&lt;h2&gt;Karte drucken&lt;/h2&gt;• In diesem Dialog &#39; +
                &#39;kann ein Kartenausdruck erzeugt werden.&lt;br&gt;&#39; +
                &#39;• Füllen Sie das Formular aus und schicken den Druckauftrag &#39; +
                &#39;ab.&lt;br&gt;• Nach kurzer Wartezeit sollte der Druck in Form &#39; +
                &#39;einer PDF Datei zum Download bereitstehen&#39;,
            labelUse: &#39;…verwenden?&#39;,
            northArrow: &#39;Nordpfeil&#39;,
            scalebar: &#39;Massstabsleiste&#39;,
            templateBrokenMessage: &#39;Template is broken and can not be used.&#39;
        }
    },

<span id='BasiGX-view-form-Print-property-bind'>    bind: {
</span>        title: &#39;{title}&#39;
    },

<span id='BasiGX-view-form-Print-property-maxHeight'>    maxHeight: 250,
</span>
<span id='BasiGX-view-form-Print-property-autoScroll'>    autoScroll: true,
</span>
    config: {
<span id='BasiGX-view-form-Print-cfg-url'>        url: null,
</span><span id='BasiGX-view-form-Print-cfg-store'>        store: null,
</span><span id='BasiGX-view-form-Print-cfg-printExtentAlwaysCentered'>        printExtentAlwaysCentered: true,
</span><span id='BasiGX-view-form-Print-cfg-printExtentMovable'>        printExtentMovable: false,
</span><span id='BasiGX-view-form-Print-cfg-printExtentScalable'>        printExtentScalable: false,
</span><span id='BasiGX-view-form-Print-cfg-printExtentRotatable'>        printExtentRotatable: false,
</span><span id='BasiGX-view-form-Print-cfg-alwaysKeepAspectRatio'>        alwaysKeepAspectRatio: false,
</span><span id='BasiGX-view-form-Print-property-skipMapMode'>        /**
</span>         * Option to be able to print without a map.
         * @type {Boolean} if true, app selection and the extent rectangle are
         * disabled.
         */
        skipMapMode: false,
<span id='BasiGX-view-form-Print-cfg-useJsonp'>        useJsonp: true
</span>    },

<span id='BasiGX-view-form-Print-property-borderColors'>    borderColors: [
</span>        &#39;#FF5050&#39;,
        &#39;#00CCFF&#39;,
        &#39;#FFFF99&#39;,
        &#39;#CCFF66&#39;
    ],

<span id='BasiGX-view-form-Print-property-layout'>    layout: &#39;form&#39;,
</span>
<span id='BasiGX-view-form-Print-property-bodyPadding'>    bodyPadding: &#39;0 5px 0 0&#39;,
</span>
<span id='BasiGX-view-form-Print-property-extentLayer'>    extentLayer: null,
</span>
<span id='BasiGX-view-form-Print-property-provider'>    provider: null,
</span>
<span id='BasiGX-view-form-Print-property-defaultType'>    defaultType: &#39;textfield&#39;,
</span>
<span id='BasiGX-view-form-Print-property-remotePrintAppsStore'>    /**
</span>     * The store containing the apps of the print servlet. This is the base of
     * the store that actually is being used in the apps combo (#appsStore).
     *
     * @type {Ext.data.Store}
     */
    remotePrintAppsStore: null,

<span id='BasiGX-view-form-Print-property-appsStore'>    /**
</span>     * The store of the combobox to choose an application from. Is created from
     * the data in the #remotePrintAppsStore.
     *
     * @type {Ext.data.Store}
     */
    appsStore: null,

<span id='BasiGX-view-form-Print-property-transformInteraction'>    /**
</span>     * The transform interaction that we may have added to the map to manipulate
     * the extent feature via dragging edges etc. Currently only added if either
     * the config #printExtentMovable or #printExtentScalable is `true` and
     * added in the method #addExtentInteractions.
     *
     * @type {ol.interaction.Transform}
     */
    transformInteraction: null,

<span id='BasiGX-view-form-Print-property-currentRotationInDegrees'>    /**
</span>     * The current rotation of the print extent in degrees
     *
     * @type {Number}
     */
    currentRotationInDegrees: 0,

<span id='BasiGX-view-form-Print-event-attributefieldsadd'>    /**
</span>     * Fires after an `attributefields`-object was added to a fieldset of e.g.
     * the layout attributes.
     *
     * This event can be used to change the appearance of e.g. a textfield.
     *
     * @event attributefieldsadd
     * @param {BasiGX.view.form.Print} printForm The print form instance.
     * @param {Object} attributefields The `attributefields`-object, which was
     *     added.
     * @param {Ext.Component} The actually added component.
     */
<span id='BasiGX-view-form-Print-event-beforeattributefieldsadd'>    /**
</span>     * Fires before an `attributefields`-object is added to the fieldset of e.g.
     * the layout attributes. If any handler for this event returns the boolean
     * value `false`, the `attributefields`-object will be skipped and not added
     * to the fieldset.
     *
     * This event can therefore be used to remove specific fields from the form
     * or to change the appearance of e.g. a textfield. You can manipulate the
     * passed `attributefields`-object and the changes will directly take
     * effect.
     *
     * @event beforeattributefieldsadd
     * @param {BasiGX.view.form.Print} printForm The print form instance.
     * @param {Object} attributefields An `attributefields`-object, which often
     *     are formfields like `textfields`, `combos` etc.
     */

    buttons: [{
        name: &#39;createPrint&#39;,
        bind: {
            text: &#39;{printFormat:uppercase} {printButtonSuffix}&#39;
        },
        formBind: true,
        handler: function() {
            this.up(&#39;form&#39;).createPrint();
        },
        disabled: true
    }, {
        name: &#39;downloadPrint&#39;,
        hidden: true,
        glyph: &#39;xf019@FontAwesome&#39;,
        bind: {
            text: &#39;{downloadButtonPrefix} {printFormat:uppercase} &#39;
        },
        link: null, // this has to be filled in application
        handler: function(btn) {
            if (btn.link) {
                window.open(btn.link);
            } else {
                Ext.raise(&#39;No downloadlink defined&#39;);
            }
        }
    }],

<span id='BasiGX-view-form-Print-property-listeners'>    listeners: {
</span>        collapse: &#39;cleanupPrintExtent&#39;,
        resize: &#39;renderAllClientInfos&#39;
    },


<span id='BasiGX-view-form-Print-method-constructor'>    /**
</span>     *
     */
    constructor: function() {
        var me = this;
        me.renderAllClientInfos = me.renderAllClientInfos.bind(this);
        me.callParent(arguments);
    },

<span id='BasiGX-view-form-Print-method-initComponent'>    /**
</span>     * Initializes the print form.
     */
    initComponent: function() {
        var me = this;
        var url = me.getUrl();

        if (!url) {
            me.html = &#39;No Url provided!&#39;;
            me.callParent();
            return;
        }

        me.callParent();

        me.createAppsStore();

        var printAppComponent = me.getPrintAppComponent();

        me.add({
            xtype: &#39;fieldcontainer&#39;,
            name: &#39;defaultFieldContainer&#39;,
            layout: &#39;form&#39;,
            items: printAppComponent,
            hidden: this.config.skipMapMode
        });

        if (!this.config.skipMapMode) {
            me.on(&#39;afterrender&#39;, me.addExtentLayer, me);
            me.on(&#39;afterrender&#39;, me.addExtentInteractions, me);
        }

        me.on(&#39;afterrender&#39;, me.addParentCollapseExpandListeners, me);
        me.on(&#39;beforeDestroy&#39;, me.cleanupPrintExtent, me);

    },

<span id='BasiGX-view-form-Print-method-createAppsStore'>    /**
</span>     *
     */
    createAppsStore: function() {
        var me = this;
        var proxy = {
            type: &#39;ajax&#39;,
            url: me.getUrl() + &#39;apps.json&#39;
        };
        if (this.getUseJsonp()) {
            proxy.type = &#39;jsonp&#39;;
            proxy.callbackKey = &#39;jsonp&#39;;
        } else {
            proxy.reader = {
                type: &#39;json&#39;
            };
        }
        var remoteAppsStore = Ext.create(&#39;Ext.data.Store&#39;, {
            autoLoad: true,
            proxy: proxy,
            listeners: {
                // The real work is done in the callback below, make sure
                // to read the docs there
                load: me.onRemoteAppStoreLoad,
                scope: me
            }
        });
        me.remotePrintAppsStore = remoteAppsStore;
    },

<span id='BasiGX-view-form-Print-method-onRemoteAppStoreLoad'>    /**
</span>     * This method looks stupid at first, but it actually serves a purpose and
     * it is the only way we found to make use of the returned json. The
     * Mapfish print servlet anwers like this:
     *
     *     dynamicExtCallback([&quot;print-app-1&quot;, &quot;print-app-2&quot;])
     *
     * We cannot make use of that data directly in ExtJS it would at least
     * expect
     *
     *     dynamicExtCallback([[&quot;print-app-1&quot;], [&quot;print-app-2&quot;]])
     *
     * In that case we could use an array reader and configure fields with
     * indices, but … as it doesn&#39;t we tackle this as follows:
     *
     * In the load callback, create a plain array of names, sort it and assign
     * it to the store.
     *
     * If you can come up with a different solution; I&#39;d be very happy.
     *
     * @param {Ext.data.Store} store The stoire that has loaded.
     * @param {Array&lt;Ext.data.Model&gt;} records The records that were loaded.
     */
    onRemoteAppStoreLoad: function(store, records) {
        var me = this;
        var rawValues = [];
        var combo = me.down(&#39;combo[name=appCombo]&#39;);
        Ext.each(records, function(rec) {
            rawValues.push(rec.data);
        });
        Ext.Array.sort(rawValues);

        combo.setStore(rawValues);
        me.appsStore = combo.getStore();
    },

<span id='BasiGX-view-form-Print-method-getPrintAppComponent'>    /**
</span>     * Returns a configuration object for a fieldset with a combo for the print
     * apps.
     *
     * @return {Object} A configuration object for a fieldset with a combo
     *     for the print apps.
     */
    getPrintAppComponent: function() {
        var component = {
            xtype: &#39;fieldset&#39;,
            bind: {
                title: &#39;{printAppFieldSetTitle}&#39;
            },
            name: &#39;print-app-fieldset&#39;,
            layout: &#39;anchor&#39;,
            items: [{
                xtype: &#39;combo&#39;,
                anchor: &#39;100%&#39;,
                name: &#39;appCombo&#39;,
                allowBlank: false,
                forceSelection: true,
                queryMode: &#39;local&#39;,
                displayField: &#39;id&#39;,
                valueField: &#39;id&#39;,
                store: this.remotePrintAppsStore,
                listeners: {
                    select: &#39;onAppSelected&#39;,
                    scope: this
                }
            }]
        };
        return component;
    },

<span id='BasiGX-view-form-Print-method-createPrint'>    /**
</span>     *
     */
    createPrint: function() {
        var me = this;
        var spec = {};
        var mapComponent = me.getMapComponent();
        var mapView = mapComponent.getMap().getView();
        var layout = me.down(&#39;combo[name=&quot;layout&quot;]&#39;).getValue();
        var format = me.down(&#39;combo[name=&quot;format&quot;]&#39;).getValue();
        var attributes = {};
        var projection = mapView.getProjection().getCode();
        var rotation;
        var featureBbox;
        var dpi;

        if (me.getPrintExtentRotatable() &amp;&amp;
            me.currentRotationInDegrees) {
            rotation = me.currentRotationInDegrees;
        } else {
            rotation = mapView.getRotation();
        }

        var gxPrintProvider = GeoExt.data.MapfishPrintProvider;

        var serializedLayers = gxPrintProvider.getSerializedLayers(
            mapComponent, this.layerFilter, this
        );

        var fieldsets = me.query(&#39;fieldset[name=attributes] fieldset&#39;);

        Ext.each(fieldsets, function(fs) {
            var name = fs.name;
            dpi = fs.down(&#39;[name=&quot;dpi&quot;]&#39;).getValue();
            if (rotation !== 0) {
                // if extent is rotated, we need to reset the geometrys
                // rotation back to 0
                var radians = rotation * Math.PI / 180;
                var geom = fs.extentFeature.getGeometry().clone();
                geom.rotate(radians, me.transformInteraction.center_);
                featureBbox = geom.getExtent();
            } else {
                featureBbox = fs.extentFeature.getGeometry().getExtent();
            }
            attributes[name] = {
                bbox: featureBbox,
                rotation: rotation,
                layers: serializedLayers.reverse(),
                projection: projection,
                dpi: dpi
            };
        }, this);
        // Get all Fields except the DPI Field
        // TODO This query should be optimized or changed into some
        // different kind of logic
        var additionalFields = me.query(
            &#39;fieldset[name=attributes]&gt;field[name!=dpi]&#39;
        );
        Ext.each(additionalFields, function(field) {

            if (field.getName() === &#39;legend&#39;) {
                attributes.legend = me.getLegendObject();
            } else if (field.getName() === &#39;scalebar&#39;) {
                attributes.scalebar = me.getScaleBarObject();
            } else if (field.getName() === &#39;northArrowDef&#39;) {
                attributes.northArrowDef = me.getNorthArrowObject();
            } else {
                attributes[field.getName()] = field.getValue();
            }
        }, this);

        var url = me.getUrl();
        var app = me.down(&#39;combo[name=appCombo]&#39;).getValue();
        spec.attributes = attributes;
        spec.layout = layout;
        var submitForm = Ext.create(&#39;Ext.form.Panel&#39;, {
            standardSubmit: true,
            url: url + app + &#39;/buildreport.&#39; + format,
            method: &#39;POST&#39;,
            items: [{
                xtype: &#39;textfield&#39;,
                name: &#39;spec&#39;,
                value: Ext.encode(spec)
            }]
        });
        submitForm.submit();
    },

<span id='BasiGX-view-form-Print-method-addParentCollapseExpandListeners'>    /**
</span>     *
     */
    addParentCollapseExpandListeners: function() {
        var parent = this.up();
        parent.on({
            collapse: &#39;cleanupPrintExtent&#39;,
            expand: &#39;renderAllClientInfos&#39;,
            scope: this
        });
    },

<span id='BasiGX-view-form-Print-method-addExtentLayer'>    /**
</span>     *
     */
    addExtentLayer: function() {
        var targetMap = BasiGX.util.Map.getMapComponent().getMap();

        // TODO MJ: the lines below are possible better suited at the
        //          cleanupPrintExtent method, but tzhat may currently
        //          be called to often.
        var existingLayer = null;
        var isPrintExtentLayerKey = BasiGX.view.form.Print.LAYER_IDENTIFIER_KEY;
        targetMap.getLayers().forEach(function(maplayer) {
            if (maplayer.get(isPrintExtentLayerKey) === true) {
                existingLayer = maplayer;
            }
        });
        if (existingLayer) {
            targetMap.removeLayer(existingLayer);
        }
        // TODO MJ: he lines above are possible better suited ...

        var layer = new ol.layer.Vector({
            source: new ol.source.Vector()
        });
        // Set our flag to identify this layer as printextentlayer
        layer.set(isPrintExtentLayerKey, true);

        // Set our internal flag to filter this layer out of the tree / legend
        var displayInLayerSwitcherKey = BasiGX.util.Layer
            .KEY_DISPLAY_IN_LAYERSWITCHER;
        layer.set(displayInLayerSwitcherKey, false);
        targetMap.addLayer(layer);
        this.extentLayer = layer;
    },

<span id='BasiGX-view-form-Print-method-addExtentInteractions'>    /**
</span>     * Adds an instance of `ol.interaction.Transform` to the map which will
     * allow to modify the print extent dynamically. Look up the property
     * named #transformInteraction for the actually created instance.
     */
    addExtentInteractions: function() {
        var me = this;
        var extentLayer = me.extentLayer;
        var needed = me.getPrintExtentMovable() || me.getPrintExtentScalable();
        if (!extentLayer || !needed) {
            return;
        }
        me.cleanupTransformInteraction();

        // TODO remove this wild guessing everywhere
        var targetMap = BasiGX.util.Map.getMapComponent().getMap();
        me.transformInteraction = new ol.interaction.Transform({
            layers: [extentLayer],
            fixedScaleRatio: true,
            keepAspectRatio: me.getAlwaysKeepAspectRatio() ?
                ol.events.condition.always :
                ol.events.condition.shiftKeyOnly,
            translate: me.getPrintExtentMovable(),
            scale: me.getPrintExtentScalable(),
            stretch: me.getPrintExtentScalable(),
            rotate: me.getPrintExtentRotatable()
        });

        function transformCallback(event) {
            me.currentExtent = event.feature;
            me.renderAllClientInfos();
            var newFeat = me.extentLayer.getSource().getFeatures()[0];
            me.transformInteraction.select(newFeat);
        }
        function rotateCallback(event) {
            me.currentRotationInDegrees += event.angle * 180 / Math.PI;
            transformCallback(event);
        }

        me.transformInteraction.on(&#39;translateend&#39;, transformCallback);
        me.transformInteraction.on(&#39;scaleend&#39;, transformCallback);
        me.transformInteraction.on(&#39;rotateend&#39;, rotateCallback);
        me.transformInteraction.setActive(true);
        targetMap.addInteraction(me.transformInteraction);
    },

<span id='BasiGX-view-form-Print-method-layerFilter'>    /**
</span>     * Filters the layer by properties or params. Used in createPrint.
     * This method can/should be overridden in the application.
     *
     * @param {ol.layer.Layer} layer The layer to test.
     * @return {Boolean} Whether to include the layer in printouts.
     */
    layerFilter: function(layer) {
        var isChecked = !!layer.checked;
        var hasName = isChecked &amp;&amp; !!layer.get(&#39;name&#39;);
        var nonOpaque = hasName &amp;&amp; (layer.get(&#39;opacity&#39;) &gt; 0);
        var inTree = nonOpaque &amp;&amp; (layer.get(
            BasiGX.util.Layer.KEY_DISPLAY_IN_LAYERSWITCHER
        ) !== false); // may be undefined for certain layers

        if (isChecked &amp;&amp; hasName &amp;&amp; nonOpaque &amp;&amp; inTree) {
            if (layer instanceof ol.layer.BaseVector &amp;&amp;
                layer.getSource().getFeatures().length &lt; 1) {
                return false;
            }
            return true;
        } else {
            return false;
        }
    },

<span id='BasiGX-view-form-Print-method-legendLayerFilter'>    /**
</span>     * Filters the layer by properties or params. Used in getLegendObject.
     * This method can/should be overriden in the application.
     *
     * @param {ol.layer.Layer} layer The layer to test.
     * @return {Boolean} Whether to include the layer in legends.
     */
    legendLayerFilter: function(layer) {
        if (layer.checked &amp;&amp; layer.get(&#39;name&#39;) &amp;&amp;
            layer.get(&#39;name&#39;) !== &#39;Hintergrundkarte&#39; &amp;&amp;
            layer.get(&#39;opacity&#39;) &gt; 0) {
            return true;
        } else {
            return false;
        }
    },

<span id='BasiGX-view-form-Print-method-getMapComponent'>    /**
</span>     * Returns the first map component on the page.
     *
     * @return {GeoExt.component.Map} The first map component on the page.
     */
    getMapComponent: function() {
        return Ext.ComponentQuery.query(&#39;gx_component_map&#39;)[0];
    },

<span id='BasiGX-view-form-Print-method-onPrintProviderReady'>    /**
</span>     * Once the PrintCapability store is loaded, we can add the generic
     * fieldset.
     *
     * @param {GeoExt.data.MapfishPrintProvider} provider The Mapfish print
     *     provider.
     */
    onPrintProviderReady: function(provider) {
        this.addGenericFieldset(provider);
        this.down(&#39;button[name=&quot;createPrint&quot;]&#39;).enable();
    },

<span id='BasiGX-view-form-Print-method-onPrintProviderError'>    /**
</span>     * Disable createPrint button if provider initialization fails.
     */
    onPrintProviderError: function() {
        this.down(&#39;button[name=&quot;createPrint&quot;]&#39;).disable();
        Ext.toast(this.getViewModel().get(&#39;templateBrokenMessage&#39;));
    },

<span id='BasiGX-view-form-Print-method-onAppSelected'>    /**
</span>     * Bound to the select event of the print applications combo, this sets up a
     * new `GeoExt.data.MapfishPrintProvider`, that, when ready, will call
     * the method #onPrintProviderReady.
     *
     * @param {Ext.form.field.ComboBox} appCombo The app combo.
     */
    onAppSelected: function(appCombo) {
        this.provider = Ext.create(&#39;GeoExt.data.MapfishPrintProvider&#39;, {
            url: this.getUrl() + appCombo.getValue() + &#39;/capabilities.json&#39;,
            listeners: {
                ready: &#39;onPrintProviderReady&#39;,
                error: &#39;onPrintProviderError&#39;,
                scope: this
            },
            useJsonp: this.getUseJsonp()
        });
    },

<span id='BasiGX-view-form-Print-method-removeGenericFieldset'>    /**
</span>     * Removes the generic fieldset from the form.
     */
    removeGenericFieldset: function() {
        var me = this;
        var fs = me.down(&#39;[name=&quot;generic-fieldset&quot;]&#39;);
        if (fs) {
            me.remove(fs);
        }
    },

<span id='BasiGX-view-form-Print-method-addGenericFieldset'>    /**
</span>     * Adds the generic fieldset to the form, with properties defined in the
     * passed `GeoExt.data.MapfishPrintProvider`.
     *
     * @param {GeoExt.data.MapfishPrintProvider} provider The Mapfish print
     *     provider.
     */
    addGenericFieldset: function(provider) {
        var me = this;
        var fs = me.down(&#39;[name=&quot;generic-fieldset&quot;]&#39;);
        var defaultFieldContainer = me.down(
            &#39;fieldcontainer[name=defaultFieldContainer]&#39;);

        if (fs) {
            fs.removeAll();
        } else {
            defaultFieldContainer.add({
                xtype: &#39;fieldset&#39;,
                bind: {
                    title: &#39;{genericFieldSetTitle}&#39;
                },
                name: &#39;generic-fieldset&#39;,
                layout: &#39;anchor&#39;,
                defaults: {
                    anchor: &#39;100%&#39;
                }
            });
        }
        this.addLayoutCombo(provider);
        this.addFormatCombo(provider);

        this.fireEvent(&#39;genericfieldsetadded&#39;);
    },

<span id='BasiGX-view-form-Print-method-addFormatCombo'>    /**
</span>     * Adds the format combo box with values from the passed provider.
     *
     * @param {GeoExt.data.MapfishPrintProvider} provider The Mapfish print
     *     provider.
     */
    addFormatCombo: function(provider) {
        var fs = this.down(&#39;fieldset[name=generic-fieldset]&#39;);
        var formatStore = provider.capabilityRec.get(&#39;formats&#39;);
        Ext.Array.sort(formatStore);
        var formatCombo = {
            xtype: &#39;combo&#39;,
            name: &#39;format&#39;,
            displayField: &#39;name&#39;,
            editable: false,
            forceSelection: true,
            queryMode: &#39;local&#39;,
            valueField: &#39;name&#39;,
            store: formatStore,
            bind: {
                fieldLabel: &#39;{formatComboLabel}&#39;,
                value: &#39;{printFormat}&#39;
            }
        };
        fs.add(formatCombo);
    },

<span id='BasiGX-view-form-Print-method-addLayoutCombo'>    /**
</span>     * Adds the layout combo box with values from the passed provider.
     *
     * @param {GeoExt.data.MapfishPrintProvider} provider The Mapfish print
     *     provider.
     */
    addLayoutCombo: function(provider) {
        var fs = this.down(&#39;fieldset[name=generic-fieldset]&#39;);
        var layoutStore = provider.capabilityRec.layouts();
        layoutStore.sort(&#39;name&#39;, &#39;ASC&#39;);
        var layoutCombo = {
            xtype: &#39;combo&#39;,
            name: &#39;layout&#39;,
            displayField: &#39;name&#39;,
            editable: false,
            forceSelection: true,
            queryMode: &#39;local&#39;,
            valueField: &#39;name&#39;,
            store: layoutStore,
            bind: {
                fieldLabel: &#39;{layoutComboLabel}&#39;
            },
            listeners: {
                change: this.onLayoutSelect,
                scope: this
            }
        };
        layoutCombo = fs.add(layoutCombo);
        layoutCombo.select(layoutStore.getAt(0));
    },

<span id='BasiGX-view-form-Print-method-onLayoutSelect'>    /**
</span>     *
     * @param {Ext.form.field.Combo} combo The layout combobox.
     * @param {String} layoutname The selected layout.
     */
    onLayoutSelect: function(combo, layoutname) {
        var me = this;
        var attributesFieldset = me.down(&#39;fieldset[name=attributes]&#39;);
        var layoutRec = combo.findRecordByValue(layoutname);
        var attributeFieldset;
        var defaultFieldContainer = me.down(
            &#39;fieldcontainer[name=defaultFieldContainer]&#39;
        );

        me.remove(attributesFieldset);

        // add the layout attributes fieldset:
        if (defaultFieldContainer &amp;&amp; attributesFieldset) {
            defaultFieldContainer.remove(attributesFieldset);
        }
        attributeFieldset = defaultFieldContainer.add({
            xtype: &#39;fieldset&#39;,
            bind: {
                title: &#39;{attributesTitle}&#39;
            },
            name: &#39;attributes&#39;,
            layout: &#39;anchor&#39;,
            defaults: {
                anchor: &#39;100%&#39;
            }
        });

        layoutRec.attributes().each(function(attribute) {
            me.addAttributeFields(attribute, attributeFieldset);
        }, me);

        // reset rotation and extent
        me.currentRotationInDegrees = 0;
        me.currentExtent = null;

        me.renderAllClientInfos();
        me.down(&#39;button[name=&quot;createPrint&quot;]&#39;).enable();
    },

<span id='BasiGX-view-form-Print-method-getMapAttributeFields'>    /**
</span>     * Returns an ExtJS configuration for a fieldset for the passed map
     * attribute record.
     *
     * @param {GeoExt.data.model.print.LayoutAttribute} attributeRec An map
     *     attribute record.
     * @return {Object} An ExtJS configuration for a fieldset for the passed
     *     map attribute record.
     */
    getMapAttributeFields: function(attributeRec) {
        var clientInfo = attributeRec.get(&#39;clientInfo&#39;);
        var mapTitle = attributeRec.get(&#39;name&#39;) + &#39; (&#39; +
            clientInfo.width + &#39; × &#39; +
            clientInfo.height + &#39;)&#39;;
        var fs = {
            xtype: &#39;fieldset&#39;,
            clientInfo: Ext.clone(clientInfo),
            title: mapTitle,
            name: attributeRec.get(&#39;name&#39;),
            items: {
                xtype: &#39;combo&#39;,
                name: &#39;dpi&#39;,
                editable: false,
                forceSelection: true,
                bind: {
                    fieldLabel: &#39;{labelDpi}&#39;
                },
                queryMode: &#39;local&#39;,
                labelWidth: 40,
                width: 150,
                value: clientInfo.dpiSuggestions[0],
                store: clientInfo.dpiSuggestions
            }
        };
        return fs;
    },

<span id='BasiGX-view-form-Print-method-getCheckBoxAttributeFields'>    /**
</span>     * Returns an ExtJS configuration for a checkbox for the passed boolean
     * attribute record.
     *
     * @param {GeoExt.data.model.print.LayoutAttribute} attributeRec A boolean
     *     attribute record.
     * @return {Object} An ExtJS configuration for a checkbox for the passed
     *     attribute record.
     */
    getCheckBoxAttributeFields: function(attributeRec) {
        return {
            xtype: &#39;checkbox&#39;,
            name: attributeRec.get(&#39;name&#39;),
            checked: true,
            bind: {
                fieldLabel: &#39;{&#39; + attributeRec.get(&#39;name&#39;) + &#39;}&#39;,
                boxLabel: &#39;{labelUse}&#39;
            }
        };
    },

<span id='BasiGX-view-form-Print-method-getNorthArrowAttributeFields'>    /**
</span>     * Returns an ExtJS configuration for a checkbox for the passed boolean
     * attribute record for enabling / disabling the north arrow.
     *
     * @param {GeoExt.data.model.print.LayoutAttribute} attributeRec A boolean
     *     attribute record.
     * @return {Object} An ExtJS configuration for a checkbox for the passed
     *     attribute record.
     */
    getNorthArrowAttributeFields: function(attributeRec) {
        return this.getCheckBoxAttributeFields(attributeRec);
    },

<span id='BasiGX-view-form-Print-method-getLegendAttributeFields'>    /**
</span>     * Returns an ExtJS configuration for a checkbox for the passed boolean
     * attribute record for enabling / disabling the legend.
     *
     * @param {GeoExt.data.model.print.LayoutAttribute} attributeRec A boolean
     *     attribute record.
     * @return {Object} An ExtJS configuration for a checkbox for the passed
     *     attribute record.
     */
    getLegendAttributeFields: function(attributeRec) {
        return this.getCheckBoxAttributeFields(attributeRec);
    },

<span id='BasiGX-view-form-Print-method-getScalebarAttributeFields'>    /**
</span>     * Returns an ExtJS configuration for a checkbox for the passed boolean
     * attribute record for enabling / disabling the scalebar.
     *
     * @param {GeoExt.data.model.print.LayoutAttribute} attributeRec A boolean
     *     attribute record.
     * @return {Object} An ExtJS configuration for a checkbox for the passed
     *     attribute record.
     */
    getScalebarAttributeFields: function(attributeRec) {
        return this.getCheckBoxAttributeFields(attributeRec);
    },

<span id='BasiGX-view-form-Print-method-getStringField'>    /**
</span>     * Returns a text field based on given attribute record. Depending on record
     * name the field label can be bound dynamically via view model.
     * At the moment only `title` attribute is translatable. For all possible
     * further attributes the name of the record will be taken as field label.
     *
     * @param {GeoExt.data.model.print.LayoutAttribute} attributeRec Record with
     *     attribute properties.
     * @return {Object} A configuration object for a textfield.
     */
    getStringField: function(attributeRec) {
        var fl = &#39;&#39;;
        var value = attributeRec.get(&#39;default&#39;);
        var name = attributeRec.get(&#39;name&#39;);

        if (attributeRec.get(&#39;name&#39;) === &#39;title&#39;) {
            fl = &#39;{mapTitleLabel}&#39;;
        } else {
            fl = name;
        }

        if (!Ext.isEmpty(fl)) {
            return {
                xtype: &#39;textfield&#39;,
                name: name,
                bind: {
                    fieldLabel: fl
                },
                value: value,
                allowBlank: true
            };
        }
    },

<span id='BasiGX-view-form-Print-method-addAttributeFields'>    /**
</span>     * Adds ExtJS components to the passed `fieldset` for the passed
     * `attributeRec`. Calls into dedicated sub methods for finding the correct
     * ExtJS component based on the `type`-property/field of the record.
     *
     * @param {GeoExt.data.model.print.LayoutAttribute} attributeRec An
     *     attribute record.
     * @param {Ext.form.Fieldset} fieldset The fieldset to add the ExtJS
     *     components to.
     */
    addAttributeFields: function(attributeRec, fieldset) {
        var me = this;
        var map = me.getMapComponent().getMap();

        var attributeFields;
        switch (attributeRec.get(&#39;type&#39;)) {
            case &#39;MapAttributeValues&#39;:
                attributeFields = me.getMapAttributeFields(attributeRec);
                if (me.getPrintExtentAlwaysCentered()) {
                    map.on(&#39;moveend&#39;, me.renderAllClientInfos);
                }
                break;
            case &#39;NorthArrowAttributeValues&#39;:
                attributeFields = me.getNorthArrowAttributeFields(attributeRec);
                break;
            case &#39;ScalebarAttributeValues&#39;:
                attributeFields = me.getScalebarAttributeFields(attributeRec);
                break;
            case &#39;LegendAttributeValue&#39;:
                attributeFields = me.getLegendAttributeFields(attributeRec);
                break;
            case &#39;String&#39;:
                attributeFields = me.getStringField(attributeRec);
                break;
            case &#39;DataSourceAttributeValue&#39;:
                Ext.toast(&#39;Data Source not yet supported&#39;);
                attributeFields = me.getStringField(attributeRec);
                break;
            default:
                break;
        }

        if (attributeFields) {
            var doContinue = me.fireEvent(
                &#39;beforeattributefieldsadd&#39;, me, attributeFields
            );
            // a beforeattributefieldsadd handler may have cancelled the adding
            if (doContinue !== false) {
                var added = fieldset.add(attributeFields);
                me.fireEvent(&#39;attributefieldsadd&#39;, me, attributeFields, added);
            }
        }
    },

<span id='BasiGX-view-form-Print-method-renderAllClientInfos'>    /**
</span>     * Method is used to adjust a print infos (e.g. dimensions or extent
     * rectangle on the map) after print layout was changed or map was zoomed
     * or paned
     */
    renderAllClientInfos: function() {
        var me = this;

        if (me._renderingClientExtents || me.getCollapsed() !== false) {
            return;
        }
        me._renderingClientExtents = true;

        if (me.extentLayer) {
            me.extentLayer.getSource().clear();
            me.resetExtentInteraction();
        }

        var fieldsets = [];
        if (me &amp;&amp; me.items) {
            fieldsets = me.query(
                &#39;fieldset[name=attributes] fieldset[name=map]&#39;
            );
        }

        Ext.each(fieldsets, function(fieldset) {
            var feat;
            if (this.getMapComponent() &amp;&amp; me.extentLayer &amp;&amp;
                    fieldset.clientInfo) {
                feat = GeoExt.data.MapfishPrintProvider.renderPrintExtent(
                    this.getMapComponent(), me.extentLayer,
                    fieldset.clientInfo
                );
                if (me.currentExtent) {
                    feat.setGeometry(me.currentExtent.getGeometry());
                }
            }
            fieldset.extentFeature = feat;
        }, this);
        delete me._renderingClientExtents;
    },

<span id='BasiGX-view-form-Print-method-resetExtentInteraction'>    /**
</span>     * Toggles the extent interaction to effectovely remove any handles (etc.)
     * that might have been added.
     */
    resetExtentInteraction: function() {
        var interaction = this.transformInteraction;
        if (interaction &amp;&amp; interaction.getActive) {
            var currentActive = interaction.getActive();
            interaction.setActive(!currentActive);
            interaction.setActive(currentActive);
        }
    },

<span id='BasiGX-view-form-Print-method-cleanupPrintExtent'>    /**
</span>     * This method removes the print extent rectangle from client after print
     * window was closed. Additionally `moveend` event on the map will
     * be unregistered here.
     */
    cleanupPrintExtent: function() {
        var me = this;
        var map = me.getMapComponent().getMap();
        me.cleanupTransformInteraction();
        if (this.extentLayer) {
            me.extentLayer.getSource().clear();
        }
        map.un(&#39;moveend&#39;, me.renderAllClientInfos);
    },

<span id='BasiGX-view-form-Print-method-cleanupTransformInteraction'>    /**
</span>     * This method effectively removes a #transformInteraction if we had one.
     */
    cleanupTransformInteraction: function() {
        var me = this;
        var interaction = me.transformInteraction;
        if (interaction) {
            interaction.setActive(false);
            var map = interaction.getMap();
            if (map) {
                map.removeInteraction(interaction);
            }
        }
        me.transformInteraction = null;
    },

<span id='BasiGX-view-form-Print-method-getLegendObject'>    /**
</span>     * Returns an object for the legends to print in a format that mapfish
     * understands.
     *
     * @return {Object} A legend serialisation for Mapfish.
     */
    getLegendObject: function() {
        var classes = [];
        var url;
        var iconString;
        var printLayers = GeoExt.data.MapfishPrintProvider.getLayerArray(
            this.getMapComponent().getLayers().getArray()
        );

        var filteredLayers = Ext.Array.filter(printLayers,
            this.legendLayerFilter);

        Ext.each(filteredLayers, function(layer) {
            if (layer.get(&#39;legendUrl&#39;)) {
                classes.push({
                    icons: [layer.get(&#39;legendUrl&#39;)],
                    name: layer.get(&#39;name&#39;)
                });
            } else {
                if (layer.getSource() instanceof ol.source.TileWMS) {
                    url = layer.getSource().getUrls()[0];
                    iconString = url + &#39;?&#39; +
                        &#39;TRANSPARENT=TRUE&amp;&#39; +
                        &#39;VERSION=1.1.1&amp;&#39; +
                        &#39;SERVICE=WMS&amp;&#39; +
                        &#39;REQUEST=GetLegendGraphic&amp;&#39; +
                        &#39;EXCEPTIONS=application%2Fvnd.ogc.se_xml&amp;&#39; +
                        &#39;FORMAT=image%2Fgif&amp;&#39; +
                        &#39;SCALE=6933504.262556662&amp;&#39; + // TODO excuse me, what ?!
                        &#39;LAYER=&#39;;
                    iconString += layer.getSource().getParams().LAYERS;
                    classes.push({
                        icons: [iconString],
                        name: layer.get(&#39;name&#39;)
                    });
                } else if (layer.getSource() instanceof ol.source.ImageWMS) {
                    url = layer.getSource().getUrl();
                    iconString = url + &#39;?&#39; +
                        &#39;TRANSPARENT=TRUE&amp;&#39; +
                        &#39;VERSION=1.1.1&amp;&#39; +
                        &#39;SERVICE=WMS&amp;&#39; +
                        &#39;REQUEST=GetLegendGraphic&amp;&#39; +
                        &#39;EXCEPTIONS=application%2Fvnd.ogc.se_xml&amp;&#39; +
                        &#39;FORMAT=image%2Fgif&amp;&#39; +
                        &#39;SCALE=6933504.262556662&amp;&#39; + // TODO excuse me, what ?!
                        &#39;LAYER=&#39;;
                    iconString += layer.getSource().getParams().LAYERS;
                    classes.push({
                        icons: [iconString],
                        name: layer.get(&#39;name&#39;)
                    });
                }
            }
        });

        var legendObj = {
            classes: classes,
            name: &#39;&#39;
        };

        return legendObj;
    },

<span id='BasiGX-view-form-Print-method-getNorthArrowObject'>    /**
</span>     * Creates and returns a NorthArrow-object for Mapfish.
     *
     * @return {Object} A north arrow serialisation for Mapfish.
     */
    getNorthArrowObject: function() {
        var northArrowObject = {};
        // This file is located right beneath the config.yaml
        northArrowObject.graphic = &#39;file://NorthArrow_10.svg&#39;;
        northArrowObject.backgroundColor = &#39;rgba(0, 0, 0, 0)&#39;;
        return northArrowObject;
    },

<span id='BasiGX-view-form-Print-method-getScaleBarObject'>    /**
</span>     * Creates and returns a ScaleBar-object
     *
     * @return {Object} A scale bar serialisation for Mapfish.
     */
    getScaleBarObject: function() {
        var scaleBarObj = {};
        scaleBarObj.color = &#39;black&#39;;
        scaleBarObj.backgroundColor = &#39;rgba(255, 255, 255, 0)&#39;;
        scaleBarObj.barBgColor = &#39;white&#39;;
        scaleBarObj.fontColor = &#39;black&#39;;
        scaleBarObj.align = &#39;right&#39;;
        scaleBarObj.intervals = 2;
        scaleBarObj.fontSize = 10;
        scaleBarObj.renderAsSvg = true;
        return scaleBarObj;
    },

<span id='BasiGX-view-form-Print-method-getLayoutRec'>    /**
</span>     * Returns the currently selected layout record.
     *
     * @return {Ext.data.Model} The selected layout record.
     */
    getLayoutRec: function() {
        var combo = this.down(&#39;combo[name=&quot;layout&quot;]&#39;);
        var value = combo.getValue();
        var rec = combo.findRecordByValue(value);
        return rec;
    }
});
</pre>
</body>
</html>
