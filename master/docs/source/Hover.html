<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* Copyright (c) 2015-present terrestris GmbH &amp; Co. KG
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
<span id='BasiGX-plugin-Hover'>/**
</span> * @class BasiGX.plugin.Hover
 */
Ext.define(&#39;BasiGX.plugin.Hover&#39;, {
    extend: &#39;Ext.plugin.Abstract&#39;,

    requires: [
        &#39;BasiGX.util.StringTemplate&#39;,
        &#39;BasiGX.util.Url&#39;
    ],

    alias: &#39;plugin.hover&#39;,
<span id='BasiGX-plugin-Hover-property-pluginId'>    pluginId: &#39;hover&#39;,
</span>
    inheritableStatics: {
<span id='BasiGX-plugin-Hover-static-property-HOVER_OVERLAY_IDENTIFIER_KEY'>        HOVER_OVERLAY_IDENTIFIER_KEY: &#39;name&#39;,
</span><span id='BasiGX-plugin-Hover-static-property-HOVER_OVERLAY_IDENTIFIER_VALUE'>        HOVER_OVERLAY_IDENTIFIER_VALUE: &#39;featureinfooverlay&#39;,
</span>
<span id='BasiGX-plugin-Hover-static-property-LAYER_HOVERABLE_PROPERTY_NAME'>        /**
</span>         * The property of a layer that holds a boolean value which indicates
         * whether this layer qualifies for hovering.
         *
         * @type {String}
         */
        LAYER_HOVERABLE_PROPERTY_NAME: &#39;hoverable&#39;,

<span id='BasiGX-plugin-Hover-static-property-LAYER_HOVER_FEATURES_REVERT_NAME'>        /**
</span>         * The property of a layer that holds a boolean value which indicates
         * whether this layer features shall be reverted on hover tooltip.
         *
         * @type {String}
         */
        LAYER_HOVER_FEATURES_REVERT_NAME: &#39;hoverFeaturesRevert&#39;,

<span id='BasiGX-plugin-Hover-static-property-LAYER_HOVERFIELD_PROPERTY_NAME'>        /**
</span>         * The property of a layer that holds a string value which indicates,
         * which field of the layer shall be shown when hovering.
         *
         * @type {String}
         */
        LAYER_HOVERFIELD_PROPERTY_NAME: &#39;hoverField&#39;,

<span id='BasiGX-plugin-Hover-static-property-HOVER_TEMPLATE_PLACEHOLDER_PREFIX'>        /**
</span>         * The prefix used in a regular expression to match any placeholder
         * field in the hover template.
         *
         * @type {String}
         */
        HOVER_TEMPLATE_PLACEHOLDER_PREFIX: &#39;{{&#39;,

<span id='BasiGX-plugin-Hover-static-property-HOVER_TEMPLATE_PLACEHOLDER_SUFFIX'>        /**
</span>         * The suffix used in a regular expression to match any placeholder
         * field in the hover template.
         *
         * @type {String}
         */
        HOVER_TEMPLATE_PLACEHOLDER_SUFFIX: &#39;}}&#39;
    },

    config: {
<span id='BasiGX-plugin-Hover-cfg-pointerRest'>        pointerRest: true,
</span><span id='BasiGX-plugin-Hover-cfg-pointerRestInterval'>        pointerRestInterval: 300,
</span><span id='BasiGX-plugin-Hover-cfg-pointerRestPixelTolerance'>        pointerRestPixelTolerance: 5,
</span><span id='BasiGX-plugin-Hover-cfg-featureInfoEpsg'>        featureInfoEpsg: &#39;EPSG:3857&#39;,
</span><span id='BasiGX-plugin-Hover-cfg-featureInfoCount'>        featureInfoCount: 50,
</span><span id='BasiGX-plugin-Hover-cfg-hoverVectorLayerSource'>        hoverVectorLayerSource: null,
</span><span id='BasiGX-plugin-Hover-cfg-hoverVectorLayer'>        hoverVectorLayer: null,
</span><span id='BasiGX-plugin-Hover-cfg-hoverVectorLayerInteraction'>        hoverVectorLayerInteraction: null,
</span><span id='BasiGX-plugin-Hover-cfg-hoverColor'>        hoverColor: &#39;rgba(255, 0, 0, 0.6)&#39;,
</span><span id='BasiGX-plugin-Hover-cfg-dynamicHoverColor'>        dynamicHoverColor: false,
</span><span id='BasiGX-plugin-Hover-cfg-enableHoverSelection'>        enableHoverSelection: true,
</span><span id='BasiGX-plugin-Hover-property-mapPaddingPositioning'>        /**
</span>         * The additional padding (in pixels) of the map component when
         * determining the positioning of the hover popup.
         *
         * @type {Number}
         */
        mapPaddingPositioning: 30,
<span id='BasiGX-plugin-Hover-cfg-maxHeight'>        maxHeight: null,
</span><span id='BasiGX-plugin-Hover-cfg-className'>        className: &#39;ol-overlay-container ol-selectable&#39;,
</span><span id='BasiGX-plugin-Hover-cfg-enableClickableLinks'>        /**
</span>         * If true, renders urls as clickable links.
         * If false, renders urls as plain strings.
         */
        enableClickableLinks: false
    },

<span id='BasiGX-plugin-Hover-cfg-selectMulti'>    /**
</span>     * Whether the `ol.interaction.Select` shall be configured to select
     * multiple features from the hover layer.
     *
     * @property {boolean}
     * @cfg
     */
    selectMulti: true,

<span id='BasiGX-plugin-Hover-cfg-selectEventOrigin'>    /**
</span>     * The origin of the select event. We support two origins:
     *
     * * `&#39;collection&#39;` (the current default), which fires whenever an `add`
     *   event of the collection of selected features is fired, and
     * * `&#39;interaction&#39;` which fires when the select interaction fires the
     *   select event.
     *
     * Older versions of ol did not expose / have the latter event, and
     * therefore the &#39;workaround&#39; with the collection events was chosen.
     *
     * @property {string}
     * @cfg
     */
    selectEventOrigin: &#39;collection&#39;,

<span id='BasiGX-plugin-Hover-property-currentHoverTarget'>    currentHoverTarget: null,
</span>
<span id='BasiGX-plugin-Hover-property-pendingRequest'>    pendingRequest: null,
</span>
<span id='BasiGX-plugin-Hover-method-init'>    init: function(cmp) {
</span>        var me = this;

        me.checkSelectEventOrigin();

        me.addHoverVectorLayerSource();
        me.addHoverVectorLayer();

        if (me.getEnableHoverSelection()) {
            me.addHoverVectorLayerInteraction();
        }

        me.setupMapEventListeners();
        me.setCmp(cmp);

        cmp.setPointerRest(me.getPointerRest());
        cmp.setPointerRestInterval(me.getPointerRestInterval());
        cmp.setPointerRestPixelTolerance(me.getPointerRestPixelTolerance());

        cmp.on(&#39;pointerrest&#39;, me.onPointerRest, me);
        cmp.on(&#39;pointerrestout&#39;, me.cleanupHoverArtifacts, me);
    },

<span id='BasiGX-plugin-Hover-method-checkSelectEventOrigin'>    /**
</span>     * Called during the initialisation phase, this method ensures that the
     * configuration option #selectEventOrigin has a valid value; e.g. either
     * is `&#39;collection&#39;` (historical default) or `&#39;interaction&#39;`.
     */
    checkSelectEventOrigin: function() {
        var me = this;
        var allowedOrigins = [&#39;collection&#39;, &#39;interaction&#39;];
        var defaultOrigin = allowedOrigins[0];
        var selOrigin = me.selectEventOrigin;
        if (!Ext.Array.contains(allowedOrigins, selOrigin)) {
            Ext.log.warn(&#39;Unexpected selectEventOrigin &quot;&#39; + selOrigin + &#39;&quot;,&#39; +
                &#39; correcting to &quot;&#39; + defaultOrigin + &#39;&quot;.&#39;);
            me.selectEventOrigin = defaultOrigin;
        }
    },

<span id='BasiGX-plugin-Hover-method-setupMapEventListeners'>    /**
</span>     * Adds any relevant listeners on the ol.Map. For now we only ensure that
     * when the top-level layerGroup changes (e.g. by adding or removing a
     * layer), we cleanup any visual artifacts from hovering.
     *
     * @private
     */
    setupMapEventListeners: function() {
        var me = this;
        var mapComponent = me.getCmp();
        var map = mapComponent.getMap();
        // whenever the layergroup changes, we need to cleanup hover artifacts
        map.on(&#39;change:layerGroup&#39;, me.cleanupHoverArtifacts.bind(me));
    },

<span id='BasiGX-plugin-Hover-method-addHoverVectorLayerInteraction'>    /**
</span>     *
     */
    addHoverVectorLayerInteraction: function() {
        var me = this;
        var mapComponent = me.getCmp();
        var map = mapComponent.getMap();

        if (!me.getHoverVectorLayerInteraction()) {
            var interaction = new ol.interaction.Select({
                multi: me.selectMulti,
                style: me.selectStyleFunction,
                layers: [me.getHoverVectorLayer()]
            });
            if (me.selectEventOrigin === &#39;collection&#39;) {
                var featureCollection = interaction.getFeatures();
                featureCollection.on(&#39;add&#39;, me.onFeatureClicked.bind(me));
            } else {
                interaction.on(&#39;select&#39;, me.onFeatureClicked.bind(me));
            }
            map.addInteraction(interaction);
            me.setHoverVectorLayerInteraction(interaction);
        }
    },

<span id='BasiGX-plugin-Hover-method-onFeatureClicked'>    /**
</span>     * Bound to either a collection- or select-interaction-event, this method
     * fires the `hoverfeaturesclick` event on the map component.
     *
     * @param {ol.Collection.Event|ol.interaction.Select.Event} olEvt The event
     *     we listen to. Is dependend on #selectEventOrigin.
     */
    onFeatureClicked: function(olEvt) {
        var me = this;
        var mapComponent = me.getCmp();
        var olFeatures;
        if (me.selectEventOrigin === &#39;collection&#39;) {
            olFeatures = olEvt.target.getArray();
        } else {
            olFeatures = olEvt.selected;
        }
        mapComponent.fireEvent(&#39;hoverfeaturesclick&#39;, olFeatures);
    },

<span id='BasiGX-plugin-Hover-method-addHoverVectorLayerSource'>    /**
</span>     *
     */
    addHoverVectorLayerSource: function() {
        var me = this;
        if (!me.getHoverVectorLayerSource()) {
            me.setHoverVectorLayerSource(new ol.source.Vector());
        }
    },

<span id='BasiGX-plugin-Hover-method-addHoverVectorLayer'>    /**
</span>     *
     */
    addHoverVectorLayer: function() {
        var me = this;
        var mapComponent = me.getCmp();
        var map = mapComponent.getMap();

        var hoverVectorLayer = me.getHoverVectorLayer();

        if (!hoverVectorLayer) {
            hoverVectorLayer = new ol.layer.Vector({
                name: &#39;hoverVectorLayer&#39;,
                source: me.getHoverVectorLayerSource(),
                visible: true,
                zIndex: 1000
            });
            map.addLayer(hoverVectorLayer);
            me.setHoverVectorLayer(hoverVectorLayer);
        }
        // Set our internal flag to filter this layer out of the tree / legend
        var inLayerSwitcherKey = BasiGX.util.Layer.KEY_DISPLAY_IN_LAYERSWITCHER;
        hoverVectorLayer.set(inLayerSwitcherKey, false);
    },

<span id='BasiGX-plugin-Hover-method-clearPendingRequests'>    /**
</span>     * Aborts pending AJAX requests, if any.
     */
    clearPendingRequests: function() {
        var me = this;
        if (me.pendingRequest) {
            Ext.Ajax.abort(me.pendingRequest);
        }
    },

<span id='BasiGX-plugin-Hover-method-requestAsynchronously'>    /**
</span>     * Requests the passed `url` asynchrounously and calls `cb` when that call
     * was successful.
     *
     * @param {String} url The URL to request.
     * @param {Function} cb The callback to execute when the call succeeded.
     */
    requestAsynchronously: function(url, cb) {
        var me = this;

        me.pendingRequest = Ext.Ajax.request({
            url: url,
            callback: function() {
                me.pendingRequest = null;
            },
            success: cb,
            failure: function(resp) {
                if (!resp.aborted) {
                    Ext.log.error(&#39;Couldn\&#39;t get FeatureInfo&#39;, resp);
                }
            }
        });
    },

<span id='BasiGX-plugin-Hover-method-cleanupHoverArtifacts'>    /**
</span>     *
     */
    cleanupHoverArtifacts: function() {
        var me = this;
        var overlayIdentifierKey = me.self.HOVER_OVERLAY_IDENTIFIER_KEY;
        var overlayIdentifierVal = me.self.HOVER_OVERLAY_IDENTIFIER_VALUE;
        var mapComponent = me.getCmp();
        var map = mapComponent.getMap();

        me.clearPendingRequests();
        me.getHoverVectorLayerSource().clear();
        map.getOverlays().forEach(function(o) {
            if (o.get(overlayIdentifierKey) === overlayIdentifierVal) {
                map.removeOverlay(o);
            }
        });
    },

<span id='BasiGX-plugin-Hover-method-onPointerRest'>    /**
</span>     * The handler for the pointerrest event on the mapcomponent.
     *
     * @param {ol.MapBrowserEvent} evt The original and most recent
     *     MapBrowserEvent event.
     */
    onPointerRest: function(evt) {
        var me = this;
        var mapComponent = me.getCmp();
        var map = mapComponent.getMap();
        var mapView = map.getView();
        var pixel = evt.pixel;
        var hoverableProp = me.self.LAYER_HOVERABLE_PROPERTY_NAME;
        var hoverFeaturesRevertProp = me.self.LAYER_HOVER_FEATURES_REVERT_NAME;
        var hoverLayers = [];
        var hoverFeatures = [];

        me.cleanupHoverArtifacts();

        map.forEachLayerAtPixel(pixel, function(layer, pixelValues) {
            var source = layer.getSource();
            var resolution = mapView.getResolution();
            var projCode = mapView.getProjection().getCode();
            var hoverable = layer.get(hoverableProp);
            var hoverFeaturesRevert = layer.get(hoverFeaturesRevertProp);

            // a layer will NOT be requested for hovering if there is a
            // &quot;hoverable&quot; property set to false. If this property is not set
            // or has any other value than &quot;false&quot;, the layer will be requested
            if (hoverable !== false) {
                if (source instanceof ol.source.TileWMS
                    || source instanceof ol.source.ImageWMS) {
                    // me.cleanupHoverArtifacts();
                    var url = source.getFeatureInfoUrl(
                        evt.coordinate,
                        resolution,
                        projCode,
                        {
                            &#39;INFO_FORMAT&#39;: &#39;application/json&#39;,
                            &#39;FEATURE_COUNT&#39;: me.getFeatureInfoCount()
                        }
                    );

                    me.requestAsynchronously(url, function(resp) {
                        // TODO: replace evt/coords with real response geometry
                        var respFeatures = (new ol.format.GeoJSON())
                            .readFeatures(resp.responseText);
                        var respProjection = (new ol.format.GeoJSON())
                            .readProjection(resp.responseText);

                        me.showHoverFeature(
                            layer, respFeatures, respProjection
                        );

                        Ext.each(respFeatures, function(feature) {
                            feature.set(&#39;layer&#39;, layer);
                            var featureStyle = me.highlightStyleFunction(
                                feature, resolution, pixelValues);
                            feature.setStyle(featureStyle);
                            hoverFeatures.push(feature);
                        });
                        if (hoverFeaturesRevert) {
                            hoverFeatures.reverse();
                        }

                        hoverLayers.push(layer);

                        me.showHoverToolTip(evt, hoverLayers, hoverFeatures);
                    });
                } else if (source instanceof ol.source.Vector) {
                    // VECTOR!
                    map.forEachFeatureAtPixel(pixel, function(feat) {
                        if (layer.get(&#39;type&#39;) === &#39;WFS&#39; ||
                            layer.get(&#39;type&#39;) === &#39;WFSCluster&#39;) {
                            var hvl = me.getHoverVectorLayer();
                            // TODO This should be dynamically generated
                            // from the clusterStyle
                            hvl.setStyle(me.highlightStyleFunction);
                        }
                        if (!Ext.Array.contains(hoverLayers, layer)) {
                            hoverLayers.push(layer);
                        }
                        if (feat.get(&#39;layer&#39;) === layer) {
                            var clone = feat.clone();
                            clone.setId(feat.getId());

                            var hoverFeaturesIds = Ext.Array.map(hoverFeatures,
                                function(hoverFeat) {
                                    return hoverFeat.getId();
                                });
                            if (!Ext.Array.contains(hoverFeaturesIds,
                                feat.getId())) {
                                var style = me.highlightStyleFunction(
                                    clone, resolution, pixel);
                                clone.setStyle(style);
                                hoverFeatures.push(clone);
                            }
                        }
                        me.showHoverFeature(layer, hoverFeatures);
                        me.currentHoverTarget = feat;
                    }, {
                        layerFilter: function(vectorCand) {
                            return vectorCand === layer;
                        }
                    });
                }
            }
        }, {
            layerFilter: me.hoverLayerFilter.bind(me)
        });

        me.showHoverToolTip(evt, hoverLayers, hoverFeatures);
    },

<span id='BasiGX-plugin-Hover-method-hoverLayerFilter'>    /**
</span>     * @param {ol.layer.Base} candidate The layer to check.
     * @return {Boolean} Whether the passed layer should be hoverable.
     */
    hoverLayerFilter: function(candidate) {
        var me = this;
        var hoverableProp = me.self.LAYER_HOVERABLE_PROPERTY_NAME;
        if (candidate.get(hoverableProp) ||
            candidate.get(&#39;type&#39;) === &#39;WFSCluster&#39;) {
            return true;
        } else {
            return false;
        }
    },

<span id='BasiGX-plugin-Hover-method-showHoverFeature'>    /**
</span>     * Adds the passed features to the hover vector layer.
     *
     * @param {ol.layer.Layer} layer The layer. Currently unused in the method.
     * @param {Array&lt;ol.Feature&gt;} features The features to hover by adding them
     *     to the source of the hover vector layer.
     * @param {ol.Projection} projection The projection of the features.
     */
    showHoverFeature: function(layer, features, projection) {
        var me = this;
        var mapComponent = me.getCmp();
        var map = mapComponent.getMap();
        var proj = me.getFeatureInfoEpsg();
        if (projection) {
            proj = projection;
        }
        var source = me.getHoverVectorLayerSource();
        Ext.each(features, function(feat) {
            var g = feat.getGeometry();
            if (g) {
                g.transform(proj, map.getView().getProjection());
            }
            if (!Ext.Array.contains(source.getFeatures(),
                feat)) {
                source.addFeature(feat);
            }
        });
    },

<span id='BasiGX-plugin-Hover-method-showHoverToolTip'>    /**
</span>     * Shows the hover tooltip.
     *
     * @param {ol.MapBrowserEvent} evt The OpenLayers event, containing e.g.
     *     the coordinate.
     * @param {Array&lt;ol.layer.Layer&gt;} layers The layers that the features may
     *     originate from.
     * @param {Array&lt;ol.Feature&gt;} features The features that were hovered.
     */
    showHoverToolTip: function(evt, layers, features) {
        var me = this;
        var overlayIdentifierKey = me.self.HOVER_OVERLAY_IDENTIFIER_KEY;
        var overlayIdentifierVal = me.self.HOVER_OVERLAY_IDENTIFIER_VALUE;
        var mapComponent = me.getCmp();
        var map = mapComponent.getMap();
        var coords = evt.coordinate;

        if (layers.length &gt; 0 &amp;&amp; features.length &gt; 0) {
            map.getOverlays().forEach(function(o) {
                if (o.get(overlayIdentifierKey) === overlayIdentifierVal) {
                    map.removeOverlay(o);
                }
            });

            var div = Ext.dom.Helper.createDom(&#39;&lt;div&gt;&#39;);
            div.className = &#39;feature-hover-popup&#39;;
            div.innerHTML = this.getToolTipHtml(layers, features);

            var positioningConfig = me.getPositioningConfig(
                evt.pixel, div, mapComponent
            );

            var overlay = new ol.Overlay({
                position: coords,
                offset: positioningConfig.offset,
                positioning: positioningConfig.positioning,
                element: div,
                className: this.getClassName()
            });
            overlay.set(overlayIdentifierKey, overlayIdentifierVal);
            map.addOverlay(overlay);
        }

    },

<span id='BasiGX-plugin-Hover-method-getPositioningConfig'>    /**
</span>     * Return a positioning configuration object that has appropriate values at
     * the keys `offset` and `positioning` for the passed pixel, div and
     * mapComponent. The returned object is ready to be used to configure an
     * `ol.Overlay` which shall hold the content of `div` and be placed at
     * `pixel` within the `mapComponent`.
     *
     * The passed pixel location can also be outside of the map, i.e. negative
     * or bigger than the map&#39;s pixel bounds.
     *
     * @param {Array&lt;Number&gt;} pixel The pixel location where the overlay shall
     *     eventually be positioned.
     * @param {HTMLDivElement} div The div which is to be placed inside the
     *     popup. This is expected to be not already rendered inside the page.
     * @param {BasiGX.view.component.Map} mapComponent The map component, where
     *     the overlay will be placed.
     * @return {Object} An object with `offset` and `positioning` information.
     */
    getPositioningConfig: function(pixel, div, mapComponent) {
        // measure the passed div first:
        div.style.display = &#39;table-cell&#39;; // so we can measure it!
        var divEl = Ext.get(Ext.getBody().dom.appendChild(div));
        var divDims = [divEl.getWidth(), divEl.getHeight()];
        if (this.maxHeight) {
            divDims[1] = Math.min(divDims[1], this.maxHeight);
        }
        div.style.display = &#39;&#39;; // undo styling,
        div.parentNode.removeChild(div);

        var mapEl = mapComponent.getEl();
        var mapDims = [mapEl.getWidth(), mapEl.getHeight()];

        // have some padding so that popups might be considered near whatever,
        // when technically they are not.
        var threshold = this.getMapPaddingPositioning();
        var dimLeftRight = divDims[0] + threshold;
        var dimTopBottom = divDims[1] + threshold;

        // fallback positioning
        var positioning = [&#39;top&#39;, &#39;left&#39;];
        var offset = [20, 0];

        if (pixel[0] &gt;= mapDims[0] - dimLeftRight) {
            // near the right
            offset[0] = -1 * (offset[0] + divDims[0]);
            if (pixel[0] &gt; mapDims[0]) {
                offset[0] += mapDims[0] - pixel[0];
            }
        } else if (pixel[0] &lt;= dimLeftRight) {
            // near the left
            positioning[1] = &#39;right&#39;;
            offset[0] = offset[0] + divDims[0];
            if (pixel[0] &lt; 0) {
                offset[0] += Math.abs(pixel[0]);
            }
        }

        if (pixel[1] &gt;= mapDims[1] - dimTopBottom) {
            // near the bottom
            offset[1] = -1 * (offset[1] + divDims[1]);
            if (pixel[1] &gt; mapDims[1]) {
                offset[1] += mapDims[1] - pixel[1];
            }
        } else if (pixel[1] &lt;= dimTopBottom) {
            // near the top
            positioning[0] = &#39;bottom&#39;;
            offset[1] = offset[1] + divDims[1];
            if (pixel[1] &lt; 0) {
                offset[1] += Math.abs(pixel[1]);
            }
        }

        return {
            positioning: positioning.join(&#39;-&#39;),
            offset: offset
        };
    },

<span id='BasiGX-plugin-Hover-method-getToolTipHtml'>    /**
</span>     * Given a set of `layers` and features that stem from these, get the HTML
     * for the tooltip.
     *
     * @param {Array&lt;ol.layer.Base&gt;} layers The layers from which the features
     *     stem.
     * @param {Array&lt;ol.Feature&gt;} features The features that were hovered.
     * @return {String} The HTML for the tooltip.
     */
    getToolTipHtml: function(layers, features) {
        var me = this;
        var innerHtml = &#39;&#39;;
        var hoverfieldProp = me.self.LAYER_HOVERFIELD_PROPERTY_NAME;
        var templateUtil = BasiGX.util.StringTemplate;
        var urlUtil = BasiGX.util.Url;
        var templateConfig = {
            prefix: me.self.HOVER_TEMPLATE_PLACEHOLDER_PREFIX,
            suffix: me.self.HOVER_TEMPLATE_PLACEHOLDER_SUFFIX
        };

        Ext.each(layers, function(layer) {

            var layerTitle = &#39;&lt;b&gt;&#39; + layer.get(&#39;name&#39;) + &#39;&lt;/b&gt;&#39;;
            var hoverInfo = &#39;&#39;;

            Ext.each(features, function(feat) {
                if (feat &amp;&amp; feat.get(&#39;layer&#39;) === layer) {
                    var hoverFieldProp = layer.get(hoverfieldProp);

                    var hoverText = templateUtil.getTextFromTemplate(
                        feat, hoverFieldProp, templateConfig);

                    if (layer.get(&#39;type&#39;) === &#39;WFSCluster&#39;) {
                        var count = feat.get(&#39;count&#39;);
                        hoverInfo += &#39;&lt;br /&gt;&#39; + count;
                    } else {
                        if (
                            me.getEnableClickableLinks()
                            &amp;&amp; urlUtil.isUrl(hoverText)
                        ) {
                            hoverInfo += &#39;&lt;br /&gt;&lt;a href=&quot;&#39;
                                + hoverText
                                + &#39;&quot; target=&quot;_blank&quot;&gt;&#39;
                                + hoverText
                                + &#39;&lt;/a&gt;&#39;;
                        } else {
                            hoverInfo += &#39;&lt;br /&gt;&#39; + hoverText;
                        }
                    }
                }
            });
            if (hoverInfo) {
                if (innerHtml.length === 0) {
                    innerHtml += layerTitle + hoverInfo;
                } else {
                    innerHtml += &#39;&lt;br /&gt;&#39; + layerTitle + hoverInfo;
                }
            }
        });

        return innerHtml;
    },

<span id='BasiGX-plugin-Hover-method-transparify'>    /**
</span>     * Returns another variant of the passed `baseColor` with the passed
     * `alpha` value. This can be used to get e.g. a half transparent reddish
     * color from a true red. If no `alpha` is passed, `1` is assumed. One
     * could therefore effectively use this to turn a half-transparent reddish
     * color into true red by simply no passing an alpha.
     *
     * @param {Array&lt;Number&gt;} baseColor An array of three (or four) numbers for
     *     the `r`, `g`, `b` (and `a`) parts of a color. All of `r`, `g` and `b`
     *     range from `0` to `255`, only integer values make sense. If passed,
     *     `a` should be between `0` and `1`, and can be fractional.
     * @param {Number} alpha The new `alpha` value. Should be between `0` and
     *     `1`, and can be fractional.
     * @return {String} The new color as string, in `rgba(r, g, b, a)`-format.
     */
    transparify: function(baseColor, alpha) {
        var rgbaTemplate = &#39;rgba({0}, {1}, {2}, {3})&#39;;
        var fallbackBaseColor = [255, 0, 0];
        var red;
        var green;
        var blue;

        if (baseColor.length === 4 &amp;&amp; Ext.isNumber(baseColor[0]) &amp;&amp;
            Ext.isNumber(baseColor[1]) &amp;&amp; Ext.isNumber(baseColor[2])) {
            red = baseColor[0];
            green = baseColor[1];
            blue = baseColor[2];
        } else {
            red = fallbackBaseColor[0];
            green = fallbackBaseColor[1];
            blue = fallbackBaseColor[2];
        }

        return Ext.String.format(rgbaTemplate, red, green, blue, alpha || 1);
    },

<span id='BasiGX-plugin-Hover-method-highlightStyleFunction'>    /**
</span>     * An OpenLayers style function that highlights the passed feature.
     *
     * @param {ol.Feature} feature The feature to highlight.
     * @param {Number} resolution The resolution the features is rendered in.
     * @param {Array&lt;Number&gt;} baseColor The base color for highlighting.
     * @return {Array&lt;ol.style.Style&gt;} The styles to use to highlight the
     *     feature.
     */
    highlightStyleFunction: function(feature, resolution, baseColor) {
        var me = this;
        var count = feature.get(&#39;count&#39;);
        var hoverColor = me.getHoverColor();
        var dynamicHoverColor = me.getDynamicHoverColor();
        var radius = 14;
        var fontSize = 10;

        if (count &amp;&amp; count &gt; 10) {
            radius = 25;
            fontSize = 14;
        } else if (count &amp;&amp; count &lt; 4) {
            fontSize = 7;
            radius = 8;
        } else if (count) {
            radius = count * 2;
            fontSize = count * 1.3;
        }

        return [
            new ol.style.Style({
                fill: new ol.style.Fill({
                    color: dynamicHoverColor ?
                        me.transparify(baseColor, 0.3) : hoverColor
                }),
                image: new ol.style.Circle({
                    radius: radius,
                    fill: new ol.style.Fill({
                        color: dynamicHoverColor ?
                            me.transparify(baseColor, 0.4) : hoverColor
                    }),
                    stroke: new ol.style.Stroke({
                        color: dynamicHoverColor ?
                            me.transparify(baseColor, 0.6) : hoverColor
                    })
                }),
                stroke: new ol.style.Stroke({
                    color: dynamicHoverColor ?
                        me.transparify(baseColor, 0.5) : hoverColor,
                    width: 5
                }),
                text: new ol.style.Text({
                    text: count &gt; 1 ? count.toString() : &#39;&#39;,
                    font: &#39;bold &#39; + fontSize * 2 + &#39;px Arial&#39;,
                    stroke: new ol.style.Stroke({
                        color: &#39;black&#39;,
                        width: 1
                    }),
                    fill: new ol.style.Fill({
                        color: &#39;white&#39;
                    })
                })
            })
        ];
    },

<span id='BasiGX-plugin-Hover-method-selectStyleFunction'>    /**
</span>     * An OpenLayers style function for selected features.
     *
     * @param {ol.Feature} feature The feature that was selected.
     * @return {Array&lt;ol.style.Style&gt;} The styles to use to style the feature.
     */
    selectStyleFunction: function(feature) {
        var count = feature.get(&#39;count&#39;);
        var radius = 14;
        var fontSize = 10;

        if (count &amp;&amp; count &gt; 10) {
            radius = 25;
            fontSize = 14;
        } else if (count &amp;&amp; count &lt; 4) {
            fontSize = 7;
            radius = 8;
        } else if (count) {
            radius = count * 2;
            fontSize = count * 1.3;
        }

        return [
            new ol.style.Style({
                fill: new ol.style.Fill({
                    color: &#39;rgba(0, 0, 255, 0.6)&#39;
                }),
                image: new ol.style.Circle({
                    radius: radius,
                    fill: new ol.style.Fill({
                        color: &#39;rgba(0, 0, 255, 0.6)&#39;
                    }),
                    stroke: new ol.style.Stroke({
                        color: &#39;gray&#39;
                    })
                }),
                text: new ol.style.Text({
                    text: count &gt; 1 ? count.toString() : &#39;&#39;,
                    font: &#39;bold &#39; + fontSize * 2 + &#39;px Arial&#39;,
                    stroke: new ol.style.Stroke({
                        color: &#39;black&#39;,
                        width: 1
                    }),
                    fill: new ol.style.Fill({
                        color: &#39;white&#39;
                    })
                })
            })
        ];
    },

<span id='BasiGX-plugin-Hover-method-hoverClusterFeatures'>    /**
</span>     * Highlights a hovered cluster feature at the passed `pixel`, if any.
     *
     * @param {ol.Pixel} pixel An array with two numbers representing the pixel
     *     to check for a feature.
     */
    hoverClusterFeatures: function(pixel) {
        var me = this;
        var mapComponent = me.getCmp();
        var map = mapComponent.getMap();
        var wmsHoverPlugin = mapComponent.getPlugin(&#39;wmshover&#39;);

        var feature = map.forEachFeatureAtPixel(pixel, function(feat) {
            return feat;
        });

        if (feature === me.highlightFeature || !feature) {
            wmsHoverPlugin.cleanupHoverArtifacts();
            return;
        } else {
            var hvl = wmsHoverPlugin.getHoverVectorLayer();
            hvl.setStyle(me.highlightStyleFunction);
            var hvlSource = wmsHoverPlugin.getHoverVectorLayerSource();
            wmsHoverPlugin.cleanupHoverArtifacts();
            hvlSource.addFeature(feature);
            me.highLightedFeature = feature;
        }
    }
});

</pre>
</body>
</html>
